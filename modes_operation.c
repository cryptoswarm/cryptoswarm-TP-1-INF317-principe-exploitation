#include "commandes.h"
#include <readline/readline.h>
#include <readline/history.h>
#include <stdio.h>


void mode_fichier(char* nom_fichier, char* envp[]){
	FILE* fichier = fopen(nom_fichier, "r"); //ouverture lecture simple
	char buffer[512]; //max 512 caracteres par ligne

	if(NULL == fichier){
		printf("Erreur lors de l'ouverture du fichier %s\n", nom_fichier);
		return;
	}
	while( fgets( buffer, sizeof(buffer), fichier ) != NULL ) //tant que la ligne n'est pas vide on l'enregistre dans buffer.
	{
		CLIOptions *commande = parseInput(buffer); //on passe 'buffer' a la fonction qui s'occupe de le couper selon le separateur ' '
		ownCmdHandler(commande, envp);//on passe le tableau contenant la commande a la fonction qui selon la commande,
									  // une autre fct va s'executer
	}
	fclose(fichier); //fermer le fichier qu'on a ouvert pour la lecture.
}

void mode_stdin(char* envp[]){
	char *input;
	//char *rl_prompt = trouverCheminAccesLigneCommande();

	while(1){
		//input = readline(rl_prompt);//"monshell>> ");
		input = readline( trouverCheminAccesLigneCommande() ); //chemin complet de shell, se change automatiquement.
		if(strlen(input) == 0 ) continue;//Si on appuyer sur la touche enter au lieu d'entrer une commande, on raffiche l'invite de commandes.
		if( input && *input) add_history( input ); //Si la ligne lue n'est pas vide, on la sauvegarde pour une utilisation ulterieur.
		CLIOptions *commande = parseInput(input); //la ligne lue a ete separee selon le separateur ' 'et enregistre dans un tableau.

		ownCmdHandler(commande, envp);// on passe le tableau a la fonction qui execute les commandes.
	}
	free(rl_prompt);
	free(input);
}
