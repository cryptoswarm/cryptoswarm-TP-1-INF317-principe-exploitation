#include <string.h>
#include <signal.h>
#include <stdio.h>

typedef bool size_t;

typedef struct CLIOptions{
	char** command; //tableau de jetons représentant la commande et ses jetons
	int argc; //nombre d'arguemtns pour command
	
	FILE* inputStream; //flux d'entrée (habituellement stdin)
	FILE* outputStream; //flux de sortie (habituellement stdout)
	bool isBackground; //en arrrière-plan?
} CLIOptions;

/* Apres avoir lu la ligne entre par l'utilisateur. 
 * On passe cette ligne a la fonction ci-bas
 * On itere sur la longueur de la ligne et chaque fois qu'on trouve un espace, on enregistre le string dans un tableau.
 *
 * @param input, un string entre par l'utilisateur
 * @return un tableau de string.
 */

CLIOptions* parseInput(char *input) {
	CLIOptions options;
	
    options.command = malloc(8 * sizeof(char *));
    if (options.command == NULL) {
    	perror("malloc failed");
        exit(1);
    }
	
	options.argc = 0;
	options.inputStream = stdin; //contenu dans stdio
	options.outputStream = stdout; //contenu dans stdio
	options.isBackground = false;

    const char *separator = " ";
	const char *redir_input = "<";
	const char *redir_output_append = ">>"
	const char *redir_output_overwrite = ">";
	const char *background = "&";
    
	char *parsed;
	
	bool redir_output = false;
	bool redir_input = false;

    parsed = strtok(input, separator);
    while (parsed != NULL) {
		if(strcmp(parsed, background)){ //jeton d'arrière-plan, en fin de ligne de commande
			options.isBackground = true;
			break;
		}
		else if(strcmp(parsed, redir_input) && !redir_input){ //une seule redirection entrée permise
			redir_input = true;
			
			options.inputStream = fopen(parsed, "r");

			if(options.inputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		else if(strcmp(parsed, redir_output_append) && !redir_output){ //une seule redirection sortie permise
			redir_output = true;
			
			options.outputStream = fopen(parsed, "a"); //"a" -> append
			
			if(options.outputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		else if(strcmp(parsed, redir_output_overwrite) && !redir_output){ //une seule redirection sortie permise
			redir_output = true;
			
			options.outputStream = fopen(parsed, "w"); //"w" -> write (nouveau fichier vide)
			
			if(options.outputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		
		//si input ou output pas encore redirigé, le jeton présent est une commande
		else if(!(redir_input || redir_output)){ 
			options.command[options.argc] = parsed;
			options.argc++;
		}
		
		else{ //jeton présent après la redirection
			printf("Jeton invalide après redirection: %s\n", parsed);			
		}
		
		parsed = strtok(NULL, separator);
    }
    options.command[argc] = NULL; //jeton nul pour terminer options.command
    return &options;
}