#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>

typedef enum {false, true} bool;

typedef struct CLIOptions{
	char** command; //tableau de jetons représentant la commande et ses jetons
	int argc; //nombre d'arguemtns pour command
	
	FILE* inputStream; //flux d'entrée (habituellement stdin)
	FILE* outputStream; //flux de sortie (habituellement stdout)
	bool isBackground; //en arrrière-plan?
} CLIOptions;


CLIOptions* parseInput(char *input) {
	CLIOptions* mem = malloc(sizeof(CLIOptions));
	if (mem == NULL) {
    	perror("malloc failed");
        exit(1);
    }
	
	CLIOptions options = *mem;
	
    options.command = malloc(8 * sizeof(char *));
    if (options.command == NULL) {
    	perror("malloc failed");
        exit(1);
    }
	
	options.argc = 0;
	options.inputStream = stdin; //contenu dans stdio
	options.outputStream = stdout; //contenu dans stdio
	options.isBackground = false;

    const char *separator = " ";
	const char *redir_input = "<";
	const char *redir_output_append = ">>";
	const char *redir_output_overwrite = ">";
	const char *background = "&";
    
	char *parsed;
	
	bool redirecting_output = false;
	bool redirecting_input = false;

    parsed = strtok(input, separator);
    while (parsed != NULL) {
		if(strcmp(parsed, background)){ //jeton d'arrière-plan, en fin de ligne de commande
			options.isBackground = true;
			break;
		}
		else if(strcmp(parsed, redir_input) && !redirecting_input){ //une seule redirection entrée permise
			redirecting_input = true;
			
			options.inputStream = fopen(parsed, "r");

			if(options.inputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		else if(strcmp(parsed, redir_output_append) && !redirecting_output){ //une seule redirection sortie permise
			redirecting_output = true;
			
			options.outputStream = fopen(parsed, "a"); //"a" -> append
			
			if(options.outputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		else if(strcmp(parsed, redir_output_overwrite) && !redirecting_output){ //une seule redirection sortie permise
			redirecting_output = true;
			
			options.outputStream = fopen(parsed, "w"); //"w" -> write (nouveau fichier vide)
			
			if(options.outputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		
		//si input ou output pas encore redirigé, le jeton présent est une commande
		else if(!(redirecting_input || redirecting_output)){ 
			options.command[options.argc] = parsed;
			options.argc++;
		}
		
		else{ //jeton présent après la redirection
			printf("Jeton invalide après redirection: %s\n", parsed);			
		}
		
		parsed = strtok(NULL, separator);
    }
    options.command[options.argc] = NULL; //jeton nul pour terminer options.command
    return mem;
}