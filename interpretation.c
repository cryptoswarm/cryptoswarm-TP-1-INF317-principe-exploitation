#include <string.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>

#include <string.h>
 #include  <signal.h>

  /* Apres avoir lu la ligne entre par l'utilisateur. 
   * On passe cette ligne a la fonction ci-bas
   * On itere sur la longueur de la ligne et chaque fois qu'on trouve un espace, on enregistre le string dans un tableau.
   *
   * @param input, un string entre par l'utilisateur
   * @return un tableau de string.
   */
   char **parseInput(char *input) {

      char **command = malloc(8 * sizeof(char *));
      if (command == NULL) {
      		perror("malloc failed");
            exit(1);
      }

      char *separator = " ";
      char *parsed;
      int index = 0;

      parsed = strtok(input, separator);
      while (parsed != NULL) {
      		command[index] = parsed;
            index++;
            parsed = strtok(NULL, separator);
      }
      command[index] = NULL;
      return command;
   }
/*
typedef enum {false, true} bool;

typedef struct CLIOptions{
	char** command; //tableau de jetons représentant la commande et ses jetons
	int argc; //nombre d'arguemtns pour command
	
	FILE* inputStream; //flux d'entrée (habituellement stdin)
	FILE* outputStream; //flux de sortie (habituellement stdout)
	bool isBackground; //en arrrière-plan?
} CLIOptions;


CLIOptions* parseInput(char *input) {
	CLIOptions* options = malloc(sizeof(CLIOptions));
	if (options == NULL) {
    	perror("malloc failed");
        exit(1);
    }

	
    options->command = malloc(8 * sizeof(char *));
    if (options->command == NULL) {
    	perror("malloc failed");
        exit(1);
    }
	
	options->argc = 0;
	options->inputStream = stdin; //contenu dans stdio
	//options->outputStream = stdout; //contenu dans stdio
	options->isBackground = false;

    const char *separator = " ";
	const char *redir_input = "<";
	const char *redir_output_append = ">>";
	const char *redir_output_overwrite = ">";
	const char *background = "&";
    
	char *parsed;
	const char *fileName;
	int fd;
	bool redirecting_output = false;
	bool redirecting_input = false;

    parsed = strtok(input, separator);
    while (parsed != NULL) {
		if(!strcmp(parsed, background)){ //jeton d'arrière-plan, en fin de ligne de commande
			options->isBackground = true;
			break;
		}
		else if(!strcmp(parsed, redir_input) && !redirecting_input){ //une seule redirection entrée permise
			redirecting_input = true;
			
			options->inputStream = fopen(parsed, "r");

			if(options->inputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		else if(!strcmp(parsed, redir_output_append) && !redirecting_output){ //une seule redirection sortie permise
			redirecting_output = true;
			
			options->outputStream = fopen(parsed, "a"); //"a" -> append
			
			if(options->outputStream == NULL){
				printf("L'ouverture a échoué pour le fichier \"%s\"\n", parsed);
			}
		}
		else if(!strcmp(parsed, redir_output_overwrite) && !redirecting_output){ //une seule redirection sortie permise
			redirecting_output = true;

			fileName = strtok(NULL, separator);

			//options->outputStream = fopen("fileName", "w+"); //"w" -> write (nouveau fichier vide)
			if( ( fd = open( fileName, O_CREAT|O_TRUNC|O_WRONLY, 0744 ) ) < 0 ){
				perror(fileName);
				exit(1);
			}
			printf("writing output of the command %s to \"%s\"\n", (options->command)[0], fileName);

			dup2(fd, 1);
			//close(fd);
			//printf("(options->command)[0] %s\n",(options->command)[0]);
			execvp("(options->command)[0]", options->command);
			//if(fd_dup != 1)
			//{
			//	fprintf(stderr, "Failed to redirect command output.\n");
			//	return 0;
			//}
			//options->outputStream = freopen("fileName", "w+", stdout);
			//printf("nom fichier est = %s\n",fileName);

			//if(options->outputStream == NULL){
			//	printf("L'ouverture a échoué pour le fichier \"%s\"\n", fileName);//parsed);
			//}
		}
		
		//si input ou output pas encore redirigé, le jeton présent est une commande
		else if(!(redirecting_input || redirecting_output)){ 
			options->command[options->argc] = parsed;
			options->argc++;
		}
		
		else{ //jeton présent après la redirection
			printf("Jeton invalide après redirection: %s\n", parsed);			
		}
		
		parsed = strtok(NULL, separator);
    }
    (options->command)[options->argc] = NULL; //jeton nul pour terminer options.command
    return options;
}
*/
