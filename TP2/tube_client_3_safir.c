// C program to implement one side of FIFO 
// This side reads first, then reads 
#include <stdio.h> 
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <fcntl.h>

int quitterClient1(char *str)
{
	int ret =0;
	if(str[strlen(str) -1 ] == '\n' ) str[strlen(str) -1 ] = '\0';
	printf("word received in client side %s\n", str);
	if( strcmp(str, "QUIT") ==0 ){
		ret = 1;
	}else{
		printf("str is not QUIT %s\n", str);
	}
	return ret;
}

int main()
{
	int fd1;
	int fdwrite;
	int fdread;
	char reponse[100];
	//char *myfifo = "TestFifo"; //fifo filr path
	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	//mkfifo(myfifo, 0666);//creating the named file(FIFO)
	mkfifo(tube_serveur, 0666);
	mkfifo(tube_client, 0666);

	char str1[80], str2[80];
	char requet[100];
	while(1)
	{
		if( ( fdwrite = open( tube_serveur, O_WRONLY) ) < 0 )
				perror("open() error for write to tube_serveur end from client side \n");
		fgets(requet, 100, stdin);
		write(fdwrite, requet, strlen(requet)+1 );
		close(fdwrite);

		if( ( fdread = open(tube_client, O_RDONLY ) ) < 0 )
			 perror("open() error read from tube_client end\n");

		read(fdread, reponse, 100 );
		close(fdread);
		if( quitterClient1( reponse ) ){
			break;
		}
		printf("%s\n",reponse);
		//strcpy(reponse, "");
		//printf("reponse after is %s\n", reponse);

	}
	return 0;
}
