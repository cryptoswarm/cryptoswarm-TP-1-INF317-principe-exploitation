// C program to implement one side of FIFO 
// This side reads first, then reads 
#include <stdio.h> 
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <signal.h> 


void testerEtCreerNamedPiped(char *fifoName){

   if(access(fifoName, F_OK) == -1 ){
   		if( mkfifo(fifoName, 0666) != 0 ){
			fprintf(stderr, "Could not create fifo %s\n", fifoName);
        	//perror("mkfifo() %s error could not create the fifo\n", fifoName);
       	}
  	}
}


char ** traiterRequete(char *requete)//, char **tabMotRequte )
{
	char **tabMotRequte = malloc(6 * sizeof(char *));


	if(tabMotRequte == NULL){
		perror("malloc failed");
		exit(1);
	}
	char * pch;
	int i = 0;

	pch= strtok(requete," ,;");

	while(pch != NULL){
		tabMotRequte[i] = pch;
		++i;
		pch= strtok(NULL, " ,;");
	}
	tabMotRequte[i] = NULL;
	free(pch);
	return tabMotRequte;
}

void sauvegarderPid( char **motRequete, char **processPid ){

	//int pid =0;
	if( strcmp( motRequete[ 0 ], "client1" ) == 0 ){
		//sscanf( motRequete[1], "%d", &pid );
		processPid[ 0 ] = malloc( sizeof(char) );
		strcpy( processPid[ 0 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client2" ) == 0 ){
		//sscanf( motRequete[1], "%d", &pid );
		processPid[ 1 ] = malloc( sizeof(char) );
		strcpy( processPid[ 1 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client3" ) == 0 ){
		//sscanf( motRequete[1], "%d", &pid );
		processPid[ 2 ] = malloc( sizeof( char) );
		strcpy( processPid[ 2 ], motRequete[ 1 ]);
	}
}

double calculerSurfSquare(int x)
{
	return pow(x, 2);
}

double calculerSurfRectangle(int x, int y)
{
	return x*y;
}
double calculerSurfTriangle(int x, int y)
{
	return ( (double)x * y ) / 2;
}

double calculerSurfCercle(int x)
{
	double Pi = 3.14;
	return Pi * pow(x, 2);
}


//double calculerSurface(char **x)
char * calculerSurface(char **x)
{
	double surface = 0.0;
	char *reponse;
	reponse = (char*)malloc(50);
	if(strcmp(x[4], "Su*") == 0 && strcmp(x[5], "C*")==0 ){

		surface = calculerSurfSquare( atoi( x[2] ) );
		sprintf(reponse, "la surface du carreÃÅ est : %f", surface);

	}else if( strcmp(x[4], "Su*") == 0 && strcmp(x[5], "R")==0 ){

		surface = calculerSurfRectangle( atoi( x[2] ), atoi( x[3] ) );
		sprintf(reponse, "la surface du rectangle est : %f", surface);

	}else if( strcmp(x[4], "Su*") == 0 && strcmp(x[5], "T")==0 ){

		surface = calculerSurfTriangle( atoi( x[2] ), atoi( x[3] ) );
		sprintf(reponse, "la surface du tiangle est : %f", surface);

	}else if( strcmp(x[4], "Su*") == 0 && strcmp(x[5], "Cr")==0 ){
		surface = calculerSurfCercle( atoi( x[2] ) );
		sprintf(reponse, "la surface du cercle est : %f", surface);

	}else{
		surface = 0.0;
		sprintf(reponse, "la requete est mal formee donc la surface est : %f", surface);
	}
	return reponse;
}


int quitterUnClient(char *str)
{
	int ret = 0;
	if( str[strlen(str) -1 ] == '\n' )
		str[strlen(str) -1 ] = '\0';

	if( strcmp(str, "FIN") ==0 || strcmp(str, "FINFIN") ==0 ){
		ret = 1;
	}else{
		printf("word received is not FIN %s\n",str);
	}
	return ret;
}

void writeToFile(FILE *pFile, char *reponseRequete )
{
	pFile = fopen("archive_clients", "a+");
	fprintf( pFile, "%s\n", reponseRequete);
	fclose(pFile);
}

int quitterTousClient(char *str)
{
	int ret = 0;
	if( str[strlen(str) -1 ] == '\n' )
		str[strlen(str) -1 ] = '\0';
	if( strcmp(str, "FINFIN") ==0 ){
		ret = 1;
	}
	return ret;
}

#define NAME_SIZE 200

int main()
{
	int fdread;
	int fdwrite;
	int i = 0;
	int n = 0;
	int pid1 = 0;
	int pid2 = 0;
	int pid3 = 0;
	
	char *reponseRequete;
	FILE *pFile;
	//pFile = fopen("archive_clients", "a+");
	char bufferQuitAll[5] = "QUIT";

	//char *input;
	//input = calloc(NAME_SIZE, sizeof(char));
	char input[1024];
	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	testerEtCreerNamedPiped(tube_serveur);
	testerEtCreerNamedPiped(tube_client);

	char **tabMotRequte;// = (char**)malloc(4 * sizeof(char *));
	//char * pch;
	char **processPid = malloc(6 * sizeof(char *));
	//char **
	while(1)
	{
		fdread = open(tube_serveur, O_RDONLY);
		//fcntl(fdread, F_SETFL, O_NONBLOCK);
		//read(fdread, input, NAME_SIZE);
		read(fdread, input, sizeof(input) );
		close(fdread);
		printf("requete recu is : %s\n", input);
		writeToFile(pFile, input);
		tabMotRequte = traiterRequete(input);
		//pid1 = sauvegarderPid( tabMotRequte, processPid );
		//pid2 = sauvegarderPid( tabMotRequte, processPid );
		sauvegarderPid( tabMotRequte, processPid );

		while(tabMotRequte[i] != NULL){
			printf("tabMotRequte[i] = %s\n", tabMotRequte[i]);
			 //if( tabMotRequte[i][strlen(tabMotRequte[i]) -1 ] == '\n' )
			   //       tabMotRequte[i][strlen(tabMotRequte[i]) -1 ] = '\0';
		    
			++i;
		}
		i=0;

		while( processPid[ n ] != NULL){
			printf("processPid[n] = %s\d", processPid[n]);
			n++;
		}
		n = 0;

		if(!quitterUnClient( tabMotRequte[2] ) ){
			reponseRequete = calculerSurface(tabMotRequte);
			printf("reponseRequete est %s\n", reponseRequete);
			//fprintf( pFile, "%s\n",reponseRequete);

			writeToFile(pFile, reponseRequete);

			fdwrite = open(tube_client, O_WRONLY);
			write(fdwrite, reponseRequete, strlen(reponseRequete)+1);
			close(fdwrite);
		}

		if( quitterUnClient( tabMotRequte[2] ) ){
			printf("I've received FIN = %s\n", tabMotRequte[2]);
			printf("process id to be killed is %s\n", tabMotRequte[1]);
			printf("Un client vient de quitter! \n");
			//fdwrite = open(tube_client, O_WRONLY);
			//write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			int pid;
			sscanf( tabMotRequte[1], "%d", &pid );
			//close(fdwrite);
			//int pid = tabMotRequte[1];
			printf("process id to be killed is %d\n", pid);
			//kill( pid, SIGTERM);
			kill( pid, SIGQUIT);
		}


		if ( quitterTousClient( tabMotRequte[2] ) ){
			printf("I'll display the content of the file\n");
			int j = 0;
			//fdwrite = open(tube_client, O_WRONLY);
			//write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			//close(fdwrite);
			//processPid = sauvegarderPid( motRequete );
			while( processPid[ j ] != NULL){
				printf("processPid[j] = %d\n", processPid[i]);
				j++;
			}
			
			free(tabMotRequte);
			//free(input);
			free(reponseRequete);

			if(unlink(tube_serveur) < 0 ){
				printf("error erasing named pipe %s\n",tube_serveur );
			}
			if(unlink(tube_client) < 0 ){
				printf("error erasing named pipe %s\n", tube_client);
			}
			//fclose(pFile);
			break;
		}

	}
	return 0;
}

