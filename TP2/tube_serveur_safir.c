#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <signal.h>
#include <stdbool.h>

#include "calculMath.h"


void testerEtCreerNamedPiped(char *fifoName){

   if(access(fifoName, F_OK) == -1 ){
   		if( mkfifo(fifoName, 0666) != 0 ){
			fprintf(stderr, "Could not create fifo %s\n", fifoName);
        	//perror("mkfifo() %s error could not create the fifo\n", fifoName);
       	}
  	}
}


char ** traiterRequete(char *requete)
{
	char **tabMotRequte = (char**)malloc(10 * sizeof(char *));


	if(tabMotRequte == NULL){
		perror("malloc failed");
		exit(1);
	}
	char * pch;
	int i = 0;

	pch= strtok(requete," ,;");

	while(pch != NULL){
		tabMotRequte[i] = (char*)malloc( 20 * sizeof( char ) );
		strcpy(tabMotRequte[i], pch);
		++i;
		pch= strtok(NULL, " ,;");
	}
	tabMotRequte[i] = NULL;
	free(pch);
	return tabMotRequte;
}

void sauvegarderPid( char **motRequete, char **processPid ){

	if( strcmp( motRequete[ 0 ], "client1" ) == 0 ){
		processPid[ 0 ] = malloc( 25* sizeof(char) );
		strcpy( processPid[ 0 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client2" ) == 0 ){

		processPid[ 1 ] = malloc( 25* sizeof(char) );
		strcpy( processPid[ 1 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client3" ) == 0 ){

		processPid[ 2 ] = malloc( 25*sizeof( char ) );
		strcpy( processPid[ 2 ], motRequete[ 1 ] );
	}
}

/*
int quitter(char *str)
{
	int ret = 0;
	//if( str[strlen(str) -1 ] == '\n' )
	//	str[strlen(str) -1 ] = '\0';

	if( strcmp(str, "FIN\n") ==0 ) {
		ret = 1;
	}else if( strcmp(str, "FINFIN\n") ==0 ){
		ret = 2;
	}else{
		ret = 3;
	}
	return ret;
}
*/
void writeToFile(FILE *pFile, char *reponseRequete )
{
	pFile = fopen("archive_clients", "a+");
	fprintf( pFile, "%s\n", reponseRequete);
	fclose(pFile);
}



void afficherContenuFichier( FILE *pFile ){
	char **identification;

	char *buffer = (char*)malloc( 1024 * sizeof(char));//[1024];
	int nbQuestionClient1 = 0;
	int nbQuestionClient2 = 0;
	int nbQuestionClient3 = 0;
	pFile = fopen("archive_clients", "r");
	if (pFile == NULL) perror ("Error opening file");
	while( !feof( pFile ) ){

		if( fgets(buffer, sizeof( buffer )*100, pFile ) == NULL ) break;
		fputs( buffer, stdout);
		identification =  traiterRequete( buffer );
		if( strcmp( identification[0], "client1") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient1++;
			}
		}else if( strcmp( identification[0], "client2") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient2++;
			}
		}else if( strcmp( identification[0], "client3") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient3++;
			}
		}
	}
	fclose (pFile);

	printf("Client 1 : %d questions, ", nbQuestionClient1);
	printf("Client 2 : %d questions ", nbQuestionClient2);
	printf("et Client 3 : %d questions\n", nbQuestionClient3);
	printf("Merci dâ€™utiliser mon service\n");
	free( buffer );
	free( identification );

}

void repondreAuxClients( char **tabMotRequte, char *reponseRequete, FILE* pFile, int fdwrite, char *tube_client ){

	if( ( strcmp( tabMotRequte[2], "FINFIN\n") !=0 ) && ( strcmp( tabMotRequte[2], "FIN\n") !=0 ) ){
		reponseRequete = calculerSurface(tabMotRequte);
		writeToFile(pFile, reponseRequete);
		fdwrite = open(tube_client, O_WRONLY);
		write(fdwrite, reponseRequete, strlen(reponseRequete)+1);
		close(fdwrite);
	}
}

void quitterUnClient( char **tabMotRequte ){

	if( strcmp(tabMotRequte[2], "FIN\n") == 0 ){

			printf("Un client vient de quitter! \n");
			int pid;
			sscanf( tabMotRequte[1], "%d", &pid );

			//kill( pid, SIGTERM);
			kill( pid, SIGQUIT);
	}
}

bool quitterTousClients( char **tabMotRequte, FILE* pFile, char **processPid ){

	bool quitter = 0;
	int pid;
	if( strcmp(tabMotRequte[2], "FINFIN\n") == 0 ){

			quitter = 1;

			afficherContenuFichier( pFile );

			if( processPid[ 0 ] != NULL ){
				sscanf( processPid[0], "%d", &pid );
				kill( pid, SIGQUIT);
			}
			if( processPid[ 1 ] != NULL ){
				sscanf( processPid[1], "%d", &pid );
				kill( pid, SIGQUIT);
			}
			if( processPid[ 2 ] != NULL ){
				sscanf( processPid[2], "%d", &pid );
				kill( pid, SIGQUIT);
			}
	}
	return quitter;
}

void unLinkTube( char *tube_serveur, char *tube_client){

	if(unlink(tube_serveur) < 0 ){
		printf("error erasing named pipe %s\n",tube_serveur );
	}
	if(unlink(tube_client) < 0 ){
		printf("error erasing named pipe %s\n", tube_client);
	}
}


int main()
{
	int fdread;
	int fdwrite;

	char *reponseRequete;
	FILE *pFile;

	char input[1024];
	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	testerEtCreerNamedPiped(tube_serveur);
	testerEtCreerNamedPiped(tube_client);

	char **tabMotRequte;

	char **processPid = malloc(6 * sizeof(char *));

	while(1)
	{
		fdread = open(tube_serveur, O_RDONLY);
		//fcntl(fdread, F_SETFL, O_NONBLOCK);
		//read(fdread, input, NAME_SIZE);
		read(fdread, input, sizeof(input) );
		close(fdread);

		writeToFile(pFile, input);
		tabMotRequte = traiterRequete(input);

		sauvegarderPid( tabMotRequte, processPid );

		repondreAuxClients( tabMotRequte, reponseRequete, pFile, fdwrite, tube_client );
		quitterUnClient( tabMotRequte );

		if( quitterTousClients( tabMotRequte, pFile, processPid ) ){

			unLinkTube( tube_serveur, tube_client);
			//free(tabMotRequte);
			//free(reponseRequete);
			//free( processPid );
			break;
		}
	}
	return 0;
}

