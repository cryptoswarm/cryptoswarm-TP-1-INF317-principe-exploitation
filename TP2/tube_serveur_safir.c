// C program to implement one side of FIFO 
// This side reads first, then reads 
#include <stdio.h> 
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>


void traiterRequete(char *requte, char **tabMotRequte )
{
	//char **tabMotRequte = (char**)malloc(4 * sizeof(char *));


	if(tabMotRequte == NULL){
		perror("malloc failed");
		exit(1);
	}
	char str[strlen(requte)+1];
	strcpy(str, requte);
	char * pch;
	int i = 0;

	pch= strtok(str,", .-");

	while(pch != NULL){

		tabMotRequte[i] = (char*)malloc(strlen(pch) +1 );
		strcpy(tabMotRequte[i], pch);
		++i;
		pch= strtok(NULL, " ,.-");
	}
	tabMotRequte[i] = NULL;
	//return tabMotRequte;
}
double calculerSurfSquare(int x)
{
	return pow(x, 2);
}

double calculerSurfRectangle(int x, int y)
{
	return x*y;
}
double calculerSurfTriangle(int x, int y)
{
	return ( (double)x * y ) / 2;
}

//double calculerSurface(char **x)
char * calculerSurface(char **x)
{
	double surface = 0.0;
	char *reponse;
	reponse = (char*)malloc(50);
	if(strcmp(x[2], "Su*") == 0 && strcmp(x[3], "C*")==0 ){

		surface = calculerSurfSquare( atoi( x[1] ) );
		sprintf(reponse, "la surface du carreÃÅ est : %f", surface);

	}else if( strcmp(x[2], "Su*") == 0 && strcmp(x[3], "R")==0 ){

		surface = calculerSurfRectangle( atoi( x[0] ), atoi( x[1] ) );
		sprintf(reponse, "la surface du rectangle est : %f", surface);

	}else if( strcmp(x[2], "Su*") == 0 && strcmp(x[3], "T")==0 ){

		surface = calculerSurfTriangle( atoi( x[0] ), atoi( x[1] ) );
		sprintf(reponse, "la surface du tiangle est : %f", surface);

	}else{
		surface = 0.0;
		sprintf(reponse, "la requete est mal formee donc la surface est : %f", surface);
	}
	return reponse;
}


int quitterUnClient(char *str)
{
	int ret = 0;
	if( str[strlen(str) -1 ] == '\n' )
		str[strlen(str) -1 ] = '\0';

	if( strcmp(str, "FIN") ==0 || strcmp(str, "FINFIN") ==0 ){
		ret = 1;
	}else{
		printf("word received is not FIN %s\n",str);
	}
	return ret;
}

int quitterTousClient(char *str)
{
	int ret = 0;
	if( str[strlen(str) -1 ] == '\n' )
		str[strlen(str) -1 ] = '\0';
	if( strcmp(str, "FINFIN") ==0 ){
		ret = 1;
	}
	return ret;
}

#define NAME_SIZE 100

int main()
{
	int fdread;
	int fdwrite;
	int i = 0;

	//int surface = 0;
	//char requete[100];
	//char buffer[100];
	char *reponseRequete;
	FILE *pFile;
	pFile = fopen("archive_clients", "a+");
	char bufferQuitAll[5] = "QUIT";

	char *input;
	input = calloc(NAME_SIZE, sizeof(char));

	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	mkfifo(tube_serveur, 0666);
	mkfifo(tube_client, 0666);

	char **tabMotRequte = (char**)malloc(4 * sizeof(char *));
	char * pch;
	
	while(1)
	{
		fdread = open(tube_serveur, O_RDONLY);
		//fcntl(fdread, F_SETFL, O_NONBLOCK);
		read(fdread, input, NAME_SIZE);
		close(fdread);
		//fputs(input, pFile);
		fprintf( pFile, "%s\n", input);
		char str[strlen(input)+1];
		strcpy(str, input);
		pch = strtok (str," ,;");
		while(pch != NULL)
		{
			tabMotRequte[i] = (char*)malloc(strlen(pch) +1 );
			strcpy(tabMotRequte[i] , pch);
			printf("tabMotRequte[i] = %s\n", tabMotRequte[i]);
			pch = strtok (NULL, " ,;");
			++i;
		}
		//tabMotRequte[i] = NULL;
		i =0;
		if(!quitterUnClient( tabMotRequte[0] ) ){
			reponseRequete = calculerSurface(tabMotRequte);
			printf("reponseRequete est %s\n", reponseRequete);
			fprintf( pFile, "%s\n",reponseRequete);
			fdwrite = open(tube_client, O_WRONLY);
			write(fdwrite, reponseRequete, strlen(reponseRequete)+1);
			close(fdwrite);
		}

		if( quitterUnClient( tabMotRequte[0] ) ){
			printf("I've received FIN = %s\n", tabMotRequte[0]);
			printf("Un client vient de quitter! \n");
			fdwrite = open(tube_client, O_WRONLY);
			write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			close(fdwrite);
		}


		if ( quitterTousClient( tabMotRequte[0] ) ){
			printf("I'll display the content of the file\n");

			//fdwrite = open(tube_client, O_WRONLY);
			//write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			//close(fdwrite);

			free(tabMotRequte);
			free(input);
			free(pch);
			free(reponseRequete);

			if(unlink(tube_serveur) < 0 ){
				printf("error erasing named pipe %s\n",tube_serveur );
			}
			if(unlink(tube_client) < 0 ){
				printf("error erasing named pipe %s\n", tube_client);
			}
			fclose(pFile);
			break;
		}

	}
	return 0;
}

