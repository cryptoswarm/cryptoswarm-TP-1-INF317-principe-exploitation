// C program to implement one side of FIFO 
// This side reads first, then reads 
#include <stdio.h> 
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>


void traiterRequete(char *requte, char **tabMotRequte )
{
	//char **tabMotRequte = (char**)malloc(4 * sizeof(char *));


	if(tabMotRequte = NULL){
		perror("malloc failed");
		exit(1);
	}
	char str[strlen(requte)+1];
	strcpy(str, requte);
	char * pch;
	int i = 0;

	pch= strtok(str,", .-");

	while(pch != NULL){

		tabMotRequte[i] = (char*)malloc(strlen(pch) +1 );
		strcpy(tabMotRequte[i], pch);
		++i;
		pch= strtok(NULL, " ,.-");
	}
	tabMotRequte[i] = NULL;
	//return tabMotRequte;
}
double calculerSurfSquare(int x)
{
	return pow(x, 2);
}

double calculerSurfRectangle(int x, int y)
{
	return x*y;
}
double calculerSurfTriangle(int x, int y)
{
	return ( (double)x * y ) / 2;
}

double calculerSurface(char **x)
{
	double surface = 0.0;
	if(strcmp(x[2], "Su*") == 0 && strcmp(x[3], "C*")==0 ){

		surface = calculerSurfSquare( atoi( x[1] ) );

	}else if( strcmp(x[2], "Su*") == 0 && strcmp(x[3], "R")==0 ){

		surface = calculerSurfRectangle( atoi( x[0] ), atoi( x[1] ) );

	}else if( strcmp(x[2], "Su*") == 0 && strcmp(x[3], "T")==0 ){

		surface = calculerSurfTriangle( atoi( x[0] ), atoi( x[1] ) );
	}else{
		surface = 0.0;
	}
	return surface;
}


int quitterUnClient(char *str)
{
	int ret = 0;
	if( str[strlen(str) -1 ] == '\n' )
		str[strlen(str) -1 ] = '\0';

	if( strcmp(str, "FIN") ==0 || strcmp(str, "FINFIN") ==0 ){
		ret = 1;
	}else{
		printf("word received is not FIN %s\n",str);
	}
	return ret;
}

int quitterTousClient(char *str)
{
	int ret = 0;
	if( str[strlen(str) -1 ] == '\n' )
		str[strlen(str) -1 ] = '\0';
	if( strcmp(str, "FINFIN") ==0 ){
		ret = 1;
	}
	return ret;
}

#define NAME_SIZE 100

int main()
{
	int fd;
	int fdread;
	int fdwrite;
	int i = 0;
	int kk =0;

	int surface = 0;
	char requete[100];
	char buffer[100];

	char bufferQuitAll[5] = "QUIT";

	char *input;
	input = calloc(NAME_SIZE, sizeof(char));

	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	mkfifo(tube_serveur, 0666);
	mkfifo(tube_client, 0666);

	char **tabMotRequte = (char**)malloc(4 * sizeof(char *));
	char * pch;
	while(1)
	{
		fdread = open(tube_serveur, O_RDONLY);
		//fcntl(fdread, F_SETFL, O_NONBLOCK);
		read(fdread, input, NAME_SIZE);
		close(fdread);

		char str[strlen(input)+1];
		strcpy(str, input);
		pch = strtok (str," ,;");
		while(pch != NULL)
		{
			tabMotRequte[i] = (char*)malloc(strlen(pch) +1 );
			strcpy(tabMotRequte[i] , pch);
			printf("tabMotRequte[i] = %s\n", tabMotRequte[i]);
			pch = strtok (NULL, " ,;");
			++i;
		}
		//tabMotRequte[i] = NULL;
		i =0;
		if(!quitterUnClient( tabMotRequte[0] ) ){
			surface =  calculerSurface(tabMotRequte);
			sprintf(buffer, "la surface du carreÃÅ est : %d", surface); 
			fdwrite = open(tube_client, O_WRONLY);
			write(fdwrite, buffer, strlen(buffer)+1);
			close(fdwrite);
		}

		if( quitterUnClient( tabMotRequte[0] ) ){
			printf("I've received FIN = %s\n", tabMotRequte[0]);
			printf("Un client vient de quitter! \n");
			fdwrite = open(tube_client, O_WRONLY);
			write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			close(fdwrite);
		}


		if ( quitterTousClient( tabMotRequte[0] ) ){
			printf("I'll display the content of the file\n");

			//fdwrite = open(tube_client, O_WRONLY);
			//write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			//close(fdwrite);

			free(tabMotRequte);
			free(input);
			free(pch);

			break;
		}
/*
		if(unlink(tube_serveur) < 0 ){
			printf("error erasing named pipe %s\n",tube_serveur );
		}
		if(unlink(tube_client) < 0 ){
			printf("error erasing named pipe %s\n", tube_client);
		}
*/
	}
	return 0;
}

