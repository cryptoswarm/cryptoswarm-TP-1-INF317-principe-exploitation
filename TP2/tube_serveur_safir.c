#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <signal.h>
#include "calculMath.h"

void testerEtCreerNamedPiped(char *fifoName){

   if(access(fifoName, F_OK) == -1 ){
   		if( mkfifo(fifoName, 0666) != 0 ){
			fprintf(stderr, "Could not create fifo %s\n", fifoName);
        	//perror("mkfifo() %s error could not create the fifo\n", fifoName);
       	}
  	}
}


char ** traiterRequete(char *requete)
{
	char **tabMotRequte = (char**)malloc(10 * sizeof(char *));


	if(tabMotRequte == NULL){
		perror("malloc failed");
		exit(1);
	}
	char * pch;
	int i = 0;

	pch= strtok(requete," ,;");

	while(pch != NULL){
		tabMotRequte[i] = (char*)malloc( 20 * sizeof( char ) );
		strcpy(tabMotRequte[i], pch);
		++i;
		pch= strtok(NULL, " ,;");
	}
	tabMotRequte[i] = NULL;
	free(pch);
	return tabMotRequte;
}

void sauvegarderPid( char **motRequete, char **processPid ){
	//char **processPid = (char**)malloc( 3 * sizeof(char *));
	if( strcmp( motRequete[ 0 ], "client1" ) == 0 ){
		processPid[ 0 ] = malloc( 25* sizeof(char) );
		strcpy( processPid[ 0 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client2" ) == 0 ){

		processPid[ 1 ] = malloc( 25* sizeof(char) );
		strcpy( processPid[ 1 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client3" ) == 0 ){
		printf("im client 3 and my pid is %s\n", motRequete[ 1 ] );
		processPid[ 2 ] = malloc( 25*sizeof( char ) );
		strcpy( processPid[ 2 ], motRequete[ 1 ] );
	}
	//return processPid;
}


int quitter(char *str)
{
	int ret = 0;
	//if( str[strlen(str) -1 ] == '\n' )
	//	str[strlen(str) -1 ] = '\0';

	if( strcmp(str, "FIN\n") ==0 ) {
		ret = 1;
	}else if( strcmp(str, "FINFIN\n") ==0 ){
		ret = 2;
	}else{
		ret = 3;
	}
	return ret;
}

void writeToFile(FILE *pFile, char *reponseRequete )
{
	pFile = fopen("archive_clients", "a+");
	fprintf( pFile, "%s\n", reponseRequete);
	fclose(pFile);
}



void afficherContenuFichier( FILE *pFile ){
	char **identification;

	char *buffer = (char*)malloc( 1024 * sizeof(char));//[1024];
	int nbQuestionClient1 = 0;
	int nbQuestionClient2 = 0;
	int nbQuestionClient3 = 0;
	pFile = fopen("archive_clients", "r");
	if (pFile == NULL) perror ("Error opening file");
	while( !feof( pFile ) ){

		if( fgets(buffer, sizeof( buffer )*100, pFile ) == NULL ) break;
		fputs( buffer, stdout);
		identification =  traiterRequete( buffer );
		if( strcmp( identification[0], "client1") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient1++;
			}
		}else if( strcmp( identification[0], "client2") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient2++;
			}
		}else if( strcmp( identification[0], "client3") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient3++;
			}
		}
	}
	fclose (pFile);

	printf("Client 1 : %d questions, ", nbQuestionClient1);
	printf("Client 2 : %d questions ", nbQuestionClient2);
	printf("et Client 3 : %d questions\n", nbQuestionClient3);
	printf("Merci dâ€™utiliser mon service\n");
	free( buffer );
	free( identification );

}

#define NAME_SIZE 200

int main()
{
	int fdread;
	int fdwrite;
	int i = 0;
	int n = 0;

	char *reponseRequete;
	FILE *pFile;

	char input[1024];
	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	testerEtCreerNamedPiped(tube_serveur);
	testerEtCreerNamedPiped(tube_client);

	char **tabMotRequte;

	char **processPid = malloc(6 * sizeof(char *));

	while(1)
	{
		fdread = open(tube_serveur, O_RDONLY);
		//fcntl(fdread, F_SETFL, O_NONBLOCK);
		//read(fdread, input, NAME_SIZE);
		read(fdread, input, sizeof(input) );
		close(fdread);
		printf("requete recu is : %s\n", input);
		writeToFile(pFile, input);
		tabMotRequte = traiterRequete(input);

		sauvegarderPid( tabMotRequte, processPid );
/*
		while(tabMotRequte[i] != NULL){
			printf("tabMotRequte[i] = %s\n", tabMotRequte[i]);
			 //if( tabMotRequte[i][strlen(tabMotRequte[i]) -1 ] == '\n' )
			   //       tabMotRequte[i][strlen(tabMotRequte[i]) -1 ] = '\0';
			++i;
		}
		i=0;
*/
		//while( processPid[ n ] != NULL){
			//printf("processPid[0] = %s\n", processPid[0] );
			//printf("processPid[1] = %s\n", processPid[1] );
			//printf("processPid[2] = %s\n", processPid[2] );
		//	n++;
		//}
		//n = 0;

		if( quitter( tabMotRequte[2] ) == 3 ){
			reponseRequete = calculerSurface(tabMotRequte);
			//printf("reponseRequete est %s\n", reponseRequete);
			//fprintf( pFile, "%s\n",reponseRequete);

			writeToFile(pFile, reponseRequete);

			fdwrite = open(tube_client, O_WRONLY);
			write(fdwrite, reponseRequete, strlen(reponseRequete)+1);
			close(fdwrite);
		}

		//if( quitter( tabMotRequte[2] ) == 1 ){
		if( strcmp(tabMotRequte[2], "FIN\n") == 0 ){
			printf("I've received FIN = %s\n", tabMotRequte[2]);
			printf("process id to be killed is %s\n", tabMotRequte[1]);
			printf("Un client vient de quitter! \n");
			//fdwrite = open(tube_client, O_WRONLY);
			//write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			int pid;
			sscanf( tabMotRequte[1], "%d", &pid );
			//close(fdwrite);
			//int pid = tabMotRequte[1];
			printf("process id to be killed is %d\n", pid);
			//kill( pid, SIGTERM);
			kill( pid, SIGQUIT);
		}


		//if ( quitter( tabMotRequte[2] ) == 2 ){
		if( strcmp(tabMotRequte[2], "FINFIN\n") == 0 ){

			afficherContenuFichier( pFile );

			int pid;
			//while( processPid[ j ] != NULL){
			if( processPid[ 0 ] != NULL ){
				sscanf( processPid[0], "%d", &pid );
				kill( pid, SIGQUIT);
			}
			if( processPid[ 1 ] != NULL ){
				sscanf( processPid[1], "%d", &pid );
				kill( pid, SIGQUIT);
			}
			if( processPid[ 2 ] != NULL ){
				sscanf( processPid[2], "%d", &pid );
				kill( pid, SIGQUIT);
			}
				//free( processPid[ j ] );
			//	j++;
			//}

			free(tabMotRequte);
			//free(input);
			free(reponseRequete);
			free( processPid );

			if(unlink(tube_serveur) < 0 ){
				printf("error erasing named pipe %s\n",tube_serveur );
			}
			if(unlink(tube_client) < 0 ){
				printf("error erasing named pipe %s\n", tube_client);
			}
			//fclose(pFile);
			break;
		}

	}
	return 0;
}

