// C program to implement one side of FIFO 
// This side reads first, then reads 
#include <stdio.h> 
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <signal.h> 


void testerEtCreerNamedPiped(char *fifoName){

   if(access(fifoName, F_OK) == -1 ){
   		if( mkfifo(fifoName, 0666) != 0 ){
			fprintf(stderr, "Could not create fifo %s\n", fifoName);
        	//perror("mkfifo() %s error could not create the fifo\n", fifoName);
       	}
  	}
}


char ** traiterRequete(char *requete)//, char **tabMotRequte )
{
	char **tabMotRequte = malloc(6 * sizeof(char *));


	if(tabMotRequte == NULL){
		perror("malloc failed");
		exit(1);
	}
	char * pch;
	int i = 0;

	pch= strtok(requete," ,;");

	while(pch != NULL){
		tabMotRequte[i] = pch;
		++i;
		pch= strtok(NULL, " ,;");
	}
	tabMotRequte[i] = NULL;
	free(pch);
	return tabMotRequte;
}

void sauvegarderPid( char **motRequete, char **processPid ){

	if( strcmp( motRequete[ 0 ], "client1" ) == 0 ){
		processPid[ 0 ] = malloc( sizeof(char) );
		strcpy( processPid[ 0 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client2" ) == 0 ){

		processPid[ 1 ] = malloc( sizeof(char) );
		strcpy( processPid[ 1 ], motRequete[ 1 ] );
	}else if( strcmp( motRequete[ 0 ], "client3" ) == 0 ){

		processPid[ 2 ] = malloc( sizeof( char ) );
		strcpy( processPid[ 2 ], motRequete[ 1 ] );
	}
}

double calculerSurfSquare(int x)
{
	return pow(x, 2);
}

double calculerSurfRectangle(int x, int y)
{
	return x*y;
}
double calculerSurfTriangle(int x, int y)
{
	return ( (double)x * y ) / 2;
}

double calculerSurfCercle(int x)
{
	double Pi = 3.14;
	return Pi * pow(x, 2);
}


//double calculerSurface(char **x)
char * calculerSurface(char **x)
{
	double surface = 0.0;
	char *reponse;
	reponse = (char*)malloc(50);
	if(strcmp(x[4], "Su*") == 0 && strcmp(x[5], "C*")==0 ){

		surface = calculerSurfSquare( atoi( x[2] ) );
		sprintf(reponse, "la surface du carreÃÅ est : %f", surface);

	}else if( strcmp(x[4], "Su*") == 0 && strcmp(x[5], "R")==0 ){

		surface = calculerSurfRectangle( atoi( x[2] ), atoi( x[3] ) );
		sprintf(reponse, "la surface du rectangle est : %f", surface);

	}else if( strcmp(x[4], "Su*") == 0 && strcmp(x[5], "T")==0 ){

		surface = calculerSurfTriangle( atoi( x[2] ), atoi( x[3] ) );
		sprintf(reponse, "la surface du tiangle est : %f", surface);

	}else if( strcmp(x[4], "Su*") == 0 && strcmp(x[5], "Cr")==0 ){
		surface = calculerSurfCercle( atoi( x[2] ) );
		sprintf(reponse, "la surface du cercle est : %f", surface);

	}else{
		surface = 0.0;
		sprintf(reponse, "la requete est mal formee donc la surface est : %f", surface);
	}
	return reponse;
}


int quitter(char *str)
{
	int ret = 0;
	if( str[strlen(str) -1 ] == '\n' )
		str[strlen(str) -1 ] = '\0';

	if( strcmp(str, "FIN") ==0 ) {
		ret = 1;
	}else if( strcmp(str, "FINFIN") ==0 ){
		ret = 2;
	}else{
		ret = 3;
	}
	return ret;
}

void writeToFile(FILE *pFile, char *reponseRequete )
{
	pFile = fopen("archive_clients", "a+");
	fprintf( pFile, "%s\n", reponseRequete);
	fclose(pFile);
}

void afficherContenuFichier( FILE *pFile ){
	char **identification;
	char buffer[1024];
	int nbQuestionClient1 = 0;
	int nbQuestionClient2 = 0;
	int nbQuestionClient3 = 0;
	pFile = fopen("archive_clients", "r");
	while( !feof( pFile ) ){

		if( fgets(buffer, sizeof(buffer), pFile ) == NULL ) break;
		fputs( buffer, stdout);
		identification =  traiterRequete( buffer );

		if( strcmp( identification[2], "FIN") != 0 || strcmp( identification[2], "FINFIN") != 0 ){

			if( strcmp( identification[0], "client1") == 0 ){
					nbQuestionClient1++;
			}else if( strcmp( identification[0], "client2") == 0 ){
				nbQuestionClient2++;
			}else if( strcmp( identification[0], "client3") == 0 ){
				nbQuestionClient3++;
			}
		}
	}
	fclose (pFile);

	printf("Client 1 : %d questions, ", nbQuestionClient1);
	printf("Client 2 : %d questions ", nbQuestionClient2);
	printf("et Client 3 : %d questions\n", nbQuestionClient3);

}

#define NAME_SIZE 200

int main()
{
	int fdread;
	int fdwrite;
	int i = 0;
	int n = 0;

	char *reponseRequete;
	FILE *pFile;
	//pFile = fopen("archive_clients", "a+");
	char bufferQuitAll[5] = "QUIT";

	//char *input;
	//input = calloc(NAME_SIZE, sizeof(char));
	char input[1024];
	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	testerEtCreerNamedPiped(tube_serveur);
	testerEtCreerNamedPiped(tube_client);

	char **tabMotRequte;// = (char**)malloc(4 * sizeof(char *));
	//char * pch;
	char **processPid = malloc(6 * sizeof(char *));
	//char **
	while(1)
	{
		fdread = open(tube_serveur, O_RDONLY);
		//fcntl(fdread, F_SETFL, O_NONBLOCK);
		//read(fdread, input, NAME_SIZE);
		read(fdread, input, sizeof(input) );
		close(fdread);
		printf("requete recu is : %s\n", input);
		writeToFile(pFile, input);
		tabMotRequte = traiterRequete(input);
		sauvegarderPid( tabMotRequte, processPid );

		while(tabMotRequte[i] != NULL){
			printf("tabMotRequte[i] = %s\n", tabMotRequte[i]);
			 //if( tabMotRequte[i][strlen(tabMotRequte[i]) -1 ] == '\n' )
			   //       tabMotRequte[i][strlen(tabMotRequte[i]) -1 ] = '\0';
			++i;
		}
		i=0;

		while( processPid[ n ] != NULL){
			printf("processPid[n] = %s\n", processPid[n]);
			n++;
		}
		n = 0;

		if( quitter( tabMotRequte[2] ) == 3 ){
			reponseRequete = calculerSurface(tabMotRequte);
			printf("reponseRequete est %s\n", reponseRequete);
			//fprintf( pFile, "%s\n",reponseRequete);

			writeToFile(pFile, reponseRequete);

			fdwrite = open(tube_client, O_WRONLY);
			write(fdwrite, reponseRequete, strlen(reponseRequete)+1);
			close(fdwrite);
		}

		if( quitter( tabMotRequte[2] ) == 1 ){
			printf("I've received FIN = %s\n", tabMotRequte[2]);
			printf("process id to be killed is %s\n", tabMotRequte[1]);
			printf("Un client vient de quitter! \n");
			//fdwrite = open(tube_client, O_WRONLY);
			//write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			int pid;
			sscanf( tabMotRequte[1], "%d", &pid );
			//close(fdwrite);
			//int pid = tabMotRequte[1];
			printf("process id to be killed is %d\n", pid);
			//kill( pid, SIGTERM);
			kill( pid, SIGQUIT);
		}


		if ( quitter( tabMotRequte[2] ) == 2 ){
			//printf("I'll display the content of the file\n");
			afficherContenuFichier( pFile );
			int j = 0;
			int pid;
			//fdwrite = open(tube_client, O_WRONLY);
			//write(fdwrite, bufferQuitAll, strlen(bufferQuitAll)+1);
			//close(fdwrite);
			//processPid = sauvegarderPid( motRequete );
			while( processPid[ j ] != NULL){
				printf("processPid[j] = %s\n", processPid[j]);
				sscanf( processPid[j], "%d", &pid );
				kill( pid, SIGQUIT);
				j++;
			}

			free(tabMotRequte);
			//free(input);
			free(reponseRequete);

			if(unlink(tube_serveur) < 0 ){
				printf("error erasing named pipe %s\n",tube_serveur );
			}
			if(unlink(tube_client) < 0 ){
				printf("error erasing named pipe %s\n", tube_client);
			}
			//fclose(pFile);
			break;
		}

	}
	return 0;
}

