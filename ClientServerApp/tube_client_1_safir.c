// C program to implement one side of FIFO 
// This side reads first, then reads 
#include <stdio.h> 
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <fcntl.h>
#include <stdlib.h>
#include <signal.h> 

void testerEtCreerNamedPiped(char *fifoName){
	if(access(fifoName, F_OK) == -1 ){
		if( mkfifo(fifoName, 0666) != 0 ){
			fprintf(stderr, "Could not create fifo %s\n", fifoName);
		}
	}
}
/*
int quitterClient1(char *str)
{
	int ret =0;
	if(str[strlen(str) -1 ] == '\n' ) str[strlen(str) -1 ] = '\0';
	printf("word received in client side %s\n", str);
	if( strcmp(str, "QUIT") ==0 ){
		ret = 1;
	}else{
		printf("str is not QUIT %s\n", str);
	}
	return ret;
}
*/

int main()
{
	pid_t pid = getpid();

	int fdwrite;
	int fdread;
	char reponse[100];
	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	testerEtCreerNamedPiped(tube_serveur);
	testerEtCreerNamedPiped(tube_client);
	char requet[100];
	char idOfProcess[20];
	char myPid[6];
	char* sentRequete;
	strcat(idOfProcess, "client1, ");
	sprintf(myPid, "%d", pid);
	strcat(idOfProcess, myPid);
	strcat(idOfProcess, ",");

	while(1)
	{
		if( ( fdwrite = open( tube_serveur, O_WRONLY) ) < 0 )
				perror("open() error for write to tube_serveur end from client side \n");

		fgets(requet, 100, stdin);
		sentRequete = (char*)malloc( strlen(requet) + strlen(idOfProcess) + 1);

		sprintf(sentRequete, "%s %s", idOfProcess, requet);

		write(fdwrite, sentRequete, strlen(sentRequete)+1 );
		close(fdwrite);
		free(sentRequete);

		if( ( fdread = open(tube_client, O_RDONLY ) ) < 0 )
			 perror("open() error read from tube_client end\n");

		read(fdread, reponse, 100 );
		close(fdread);

		printf("%s\n",reponse);

	}
	return 0;
}
