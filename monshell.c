#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <string.h>

char **get_input(char *input) {

    char **command = malloc(8 * sizeof(char *));
    if (command == NULL) {
    	perror("malloc failed");
        exit(1);
    }

    char *separator = " ";
    char *parsed;
    int index = 0;

    parsed = strtok(input, separator);
    while (parsed != NULL) {
    	command[index] = parsed;
        index++;

        parsed = strtok(NULL, separator);
    }

    command[index] = NULL;
    return command;
}

int changeDir(char* argv[] )
{
	char cwd[1024];
	const char *path;
	if( argv[1] == NULL)
	{
		printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
	}else{
		path = argv[1];
		if( chdir(path) != 0 )
		{
			printf("%s\n","Erreur, le chemin n'existe pas");
		}
	}
	return 0;
}

/* Cette fonction utilise ce qu'on appelle escapes sequences pour effacer l'ecran.
 * \033 escape
 * [H home
 * [J new line
 * man ascii permet d'avoir plus d'informations.
 */
void clearScreaan()
{
	printf("\033[H\033[J");
}
/**
int listContentOfDirectory()
{
	return dir();
}
*/
void myexecl(char *argv[])
{
	int status;
	int ret;
	int pid = fork();
	if( pid < 0 )
	{
		perror("Echec du fork()");
		exit(1);
	}else if(pid == 0 )
	{
		if( execvp( argv[0],argv ) < 0 )
		{
			perror(argv[0]);
			exit(1);
		}
	}else
	{
		waitpid(pid, &status, WUNTRACED);
	}
}

void listerContenuEnv(char *envp[])
{
	char **env;
	for(env = envp; *env !=0; env++)
	{
		char *this = *env;
		printf("%s\n",this);
	}
}

/*
int ownCmdHandler(char** parsed )
{
     int NoOfOwnCmds = 9, i, switchOwnArg = 0;
     char* ListOfOwnCmds[NoOfOwnCmds];
     char* username;
	 char *tab;

	 //tab = parsed[1];
     ListOfOwnCmds[0] = "cd";
     ListOfOwnCmds[1] = "clr";
     ListOfOwnCmds[2] = "dir";
	 ListOfOwnCmds[3] = "environ";
	 ListOfOwnCmds[4] = "echo";
	 ListOfOwnCmds[5] = "help";
	 ListOfOwnCmds[6] = "pause";
	 ListOfOwnCmds[7] = "quit";
	 //ListOfOwnCmds[4] = "ls";

     for (i = 0; i < NoOfOwnCmds; i++) {
         if (strcmp(parsed[0], ListOfOwnCmds[i]) == 0) { //parsed[0]
             switchOwnArg = i + 1;
             break;
         }
     }

     switch (switchOwnArg) {
     case 1:
         if ( changeDir(parsed) ) //; //printf("\nGoodbye\n");
		 {
		 	return 1;
		 }
		 //break;
		
		 changeDir(parsed);
		 return 1;
     case 2:

          return 1;
     case 3:
         //openHelp();
         return 1;
     case 4:
         username = getenv("USER");
         printf("\nHello %s.\nMind that this is "
             "not a place to play around."
             "\nUse help to know more..\n",
             username);
         return 1;
     case 5:
		 listContent();
	 case 6:
	 case 7:
	 case 8:
	 	 exit(0);
     default:
         break;
     }

	return 0;
}
*/
/**
int listContent()
{
	int status;
	int ret;
	int pid = fork();
	if( pid == -1 )
	{
		 perror("Echec du fork()");
	}else if(pid == 0 )
	{
		execl("/bin/ls","ls","-l",NULL);
		perror("error in execl()");
	}
	ret = waitpid(pid, &status, 0 );
	if(ret == -1)
	{
		perror("Erreur dans le waitpid() du premier processus enfant");
	}
	return 0;
}
*/

void echoComment(char *comment[])
{
	//echo comment;
	int index =1;
	while(comment[index] != NULL )
	{
		printf("%s ",comment[index]);
		++index;
	}
	printf("\n");
	printf("\n");
}

int main(int argc, char *argv[], char *envp[])
{
	char **command;
	char *input;
	pid_t child_pid;
	int stat_loc;
	char buffer[1024];
o

	while(1)
	{
		input = readline("monshell>> ");

		command = get_input(input);

		if( strcmp( command[0], "cd" ) == 0)
		{
			changeDir( command );
			continue;
		}
		if( strcmp( command[0], "clr" ) == 0)
		{
			clearScreaan();
			continue;
		}
		if(strcmp( command[0], "dir" ) == 0)
		{
			//listContentOfDirectory();
			//continue;
		}
		if(strcmp( command[0], "environ" ) == 0)
		{
			listerContenuEnv(envp);
			continue;
		}
		if(strcmp( command[0], "echo" ) == 0)
		{
			echoComment(command);
			continue;
		}
		if( strcmp( command[0], "quit" ) == 0)
		{
			exit(0);
		}


		myexecl(command);
		free(input);
		free(command);
	}
	return 0;
}
