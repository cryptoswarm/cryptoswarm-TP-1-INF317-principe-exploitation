#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <string.h>

int changeDir(char* argv[] );
char **parseInput(char *input);
void clearScreaan();

void myexecl(char *argv[]);

void listerContenuEnv(char *envp[]);

/*
int ownCmdHandler(char** parsed )
{
     int NoOfOwnCmds = 9, i, switchOwnArg = 0;
     char* ListOfOwnCmds[NoOfOwnCmds];
     char* username;
	 char *tab;

	 //tab = parsed[1];
     ListOfOwnCmds[0] = "cd";
     ListOfOwnCmds[1] = "clr";
     ListOfOwnCmds[2] = "dir";
	 ListOfOwnCmds[3] = "environ";
	 ListOfOwnCmds[4] = "echo";
	 ListOfOwnCmds[5] = "help";
	 ListOfOwnCmds[6] = "pause";
	 ListOfOwnCmds[7] = "quit";
	 //ListOfOwnCmds[4] = "ls";

     for (i = 0; i < NoOfOwnCmds; i++) {
         if (strcmp(parsed[0], ListOfOwnCmds[i]) == 0) { //parsed[0]
             switchOwnArg = i + 1;
             break;
         }
     }

     switch (switchOwnArg) {
     case 1:
         if ( changeDir(parsed) ) //; //printf("\nGoodbye\n");
		 {
		 	return 1;
		 }
		 //break;
		
		 changeDir(parsed);
		 return 1;
     case 2:

          return 1;
     case 3:
         //openHelp();
         return 1;
     case 4:
         username = getenv("USER");
         printf("\nHello %s.\nMind that this is "
             "not a place to play around."
             "\nUse help to know more..\n",
             username);
         return 1;
     case 5:
		 listContent();
	 case 6:
	 case 7:
	 case 8:
	 	 exit(0);
     default:
         break;
     }

	return 0;
}
*/
/**
int listContent()
{
	int status;
	int ret;
	int pid = fork();
	if( pid == -1 )
	{
		 perror("Echec du fork()");
	}else if(pid == 0 )
	{
		execl("/bin/ls","ls","-l",NULL);
		perror("error in execl()");
	}
	ret = waitpid(pid, &status, 0 );
	if(ret == -1)
	{
		perror("Erreur dans le waitpid() du premier processus enfant");
	}
	return 0;
}
*/

void echoComment(char *comment[]);
int ownCmdHandler(char** parsed, char* envp[]);

