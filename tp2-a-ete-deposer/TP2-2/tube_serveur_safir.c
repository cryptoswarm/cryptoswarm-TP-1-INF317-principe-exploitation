#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <signal.h>
#include <stdbool.h>

#include "calculMath.h"

struct Clients{
	int pid;
	bool indice;
	char name[15];
};
/*
 * Tester si le tube nome existe
 * S'il n'existe pas, on le cree.
 *
 * @param fifoName, nom du tube nome
 */

void testerEtCreerNamedPiped(char *fifoName){

   if(access(fifoName, F_OK) == -1 ){
   	if( mkfifo(fifoName, 0666) != 0 ){
		fprintf(stderr, "Could not create fifo %s\n", fifoName);
        	//perror("mkfifo() %s error could not create the fifo\n", fifoName);
       	}
  }
}
/*
 *Traiter la requete envoyer par chaque client
 *le client envoi une requete de la forme suivante:
 *client1, pid, entier, entier, Su*, C*;
 *
 *@requete, la requete envoye par un client
 *@return , un tableau compose des mots constituant la requete
 */

char ** traiterRequete(char *requete)
{
	char **tabMotRequte = (char**)malloc(10 * sizeof(char *));


	if(tabMotRequte == NULL){
		perror("malloc failed");
		exit(1);
	}
	char * pch = NULL;
	int i = 0;

	pch= strtok(requete," ,;");

	while(pch != NULL){

		tabMotRequte[i] = pch;
		++i;
		pch= strtok(NULL, " ,;");
	}
	tabMotRequte[i] = NULL;
	free(pch);
	return tabMotRequte;
}

/*
 *Sauvegarder le process id de chaque client qui a ouvert une connexion avec le serveur
 *Le process id est utilise pour termine le client si ce dernier le souhaite
 *
 *@param, processPid  est le tableau qui va contenir les process if pour chaque client
 *@motRequete, est le tableau contenant les mots composant la requete.
 */
//void sauvegarderPid( char **processPid, char **motRequete){
void sauvegarderPid( struct Clients client[3], char **motRequete){

	if( strcmp( motRequete[0], "client1" ) == 0 ){
		if( client[0].indice == 0 ){
			sscanf( motRequete[ 1 ], "%d", &(client[0].pid) );
			client[0].indice= 1;
		}
	}
	if( strcmp( motRequete[0], "client2" ) == 0 ){
		if( client[1].indice == 0 ){
			sscanf( motRequete[ 1 ], "%d", &(client[1].pid) );
			client[1].indice= 1;
		}
	}
	if( strcmp( motRequete[0], "client3" ) == 0 ){
		if( client[2].indice== 0 ){
			sscanf( motRequete[1], "%d", &(client[2].pid) );
			client[2].indice = 1;
		}
	}
}

/*
 *On ecrit la requete envoyer par un des client dans le fichier
 *
 *@param pFile, est un pointeru vers le fichier
 *@param requete, est la requete envoye par le client
 */
void writeToFile(FILE *pFile, char *requete )
{
	pFile = fopen("archive_clients", "a+");
	if (pFile == NULL) perror ("Error opening file");
	fprintf( pFile, "%s\n", requete);
	fclose(pFile);
}


/*
 *Afficher le contenu du fichier sur le sortie standar
 *On traverse tous le contenu du fichier, a chaque fois qu'on lise une requete envoye par client
 *On incremenete le nombre de question envoyer par ce client
 *A la fin on afficher le nombre de question emvoye par chaque clients
 *On affiche aussi un message de remerciement.
 *
 *@param pFile pointeur vers le fichier
 */
void afficherContenuFichier( FILE *pFile ){

	char **identification = NULL;

	char *buffer = (char*)malloc( 1024 * sizeof(char));//[1024];
	int nbQuestionClient1 = 0;
	int nbQuestionClient2 = 0;
	int nbQuestionClient3 = 0;
	pFile = fopen("archive_clients", "r");
	if (pFile == NULL) perror ("Error opening file");
	while( !feof( pFile ) ){

		if( fgets(buffer, sizeof( buffer )*100, pFile ) == NULL ) break;
		fputs( buffer, stdout);
		identification =  traiterRequete( buffer );
		if( strcmp( identification[0], "client1") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient1++;

			}
		}else if( strcmp( identification[0], "client2") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient2++;

			}
		}else if( strcmp( identification[0], "client3") == 0 ){
			if( ( strcmp( identification[2], "FINFIN\n") != 0 ) && ( strcmp( identification[2], "FIN\n") != 0 ) ){
				nbQuestionClient3++;

			}
		}
	}
	fclose (pFile);

	printf("Client 1 : %d questions, ", nbQuestionClient1);
	printf("Client 2 : %d questions ", nbQuestionClient2);
	printf("et Client 3 : %d questions\n", nbQuestionClient3);
	printf("Merci dâ€™utiliser mon service\n");

	free( buffer );
}
/*
 *Repondre a la requete du client
 *Apres avoir traiter la requete
 *et calculer la surface ou le perimetre
 *On envoit la reponse au client designe
 *
 *@param tabMotRequte, mots constituant la requete
 *@param pFile pointeur vers fichier
 *@param fdwrite, file descriptor
 *@param tube_client, nom du nome client
 */
void repondreAuxClients( char **tabMotRequte , FILE* pFile, int fdwrite, char *tube_client ){

	char *reponseRequete = NULL;
	if( ( strcmp( tabMotRequte[2], "FINFIN\n") !=0 ) && ( strcmp( tabMotRequte[2], "FIN\n") !=0 ) ){
		reponseRequete = calculerSurface(tabMotRequte);
		writeToFile(pFile, reponseRequete);
		fdwrite = open(tube_client, O_WRONLY);
		write(fdwrite, reponseRequete, strlen(reponseRequete)+1);
		close(fdwrite);
	}
}
/*
 *A la suite de la reception du mot "FIN" de la part d'un client
 *On envoie un signal Quit a ce dernier
 *
 *@param tabMotRequte,mots constituant la requete
 *@param client, la structure contenant les membres de chaque client
 */
void quitterUnClient( char **motRequete, struct Clients client[3]){

	if( strcmp(motRequete[2], "FIN\n") == 0 ){
		if( strcmp( motRequete[0], "client1" ) == 0 ){
			client[0].indice= 0;
			kill( client[0].pid, SIGQUIT);
		}
		else if( strcmp( motRequete[0], "client2") == 0 ){
			client[1].indice = 0;
			kill( client[1].pid, SIGQUIT);
		}
		else if( strcmp( motRequete[0], "client3") == 0 ){
			client[2].indice = 0;
			kill( client[2].pid, SIGQUIT);
		}
		printf("Un client vient de quitter! \n");
	}
}
/*
 *A la suit ede la reception du mot "FINFIN" de la part d'un client
 *On envoie un signal QUIT a tous les clients qui ont etablit une conexxion avec le serveur
 *
 *@param tabMotRequte, mots constituant la requete
 *@param pFile, pointeur vers le fichier
 *@param client, la structure contenant les membres de chaque client
 *
 *@return vrai si on ferme la conexxion avec tous les clients, faux sinon
 */
bool quitterTousClients( char **tabMotRequte, FILE* pFile, struct Clients client[3] ){

	bool quitter = 0;

	if( strcmp(tabMotRequte[2], "FINFIN\n") == 0 ){
		quitter = 1;
		afficherContenuFichier( pFile );

		if( client[0].indice == 1 ){
			kill( client[0].pid, SIGQUIT);
		}
		if( client[1].indice == 1 ){
			kill( client[1].pid, SIGQUIT);
		}
		if( client[2].indice == 1 ){
			kill( client[2].pid, SIGQUIT);
		}
	}
	return quitter;
}
/*
 *Supprimer le nom de tube nome du sustem fichier
 *
 *@param, tube_serveur tube nome serveur
 *@param, tube_serveur tube nome client
 */
void unLinkTube( char *tube_serveur, char *tube_client){

	if(unlink(tube_serveur) < 0 ){
		printf("error erasing named pipe %s\n",tube_serveur );
	}
	if(unlink(tube_client) < 0 ){
		printf("error erasing named pipe %s\n", tube_client);
	}
}


int main()
{
	int fdread =0;
	int fdwrite =0;
	FILE *pFile = NULL;

	struct Clients client[3] = {
			{0, 0,"client1"},
			{0, 0,"client2"},
			{0, 0,"client3"}
	};


	char *requete = malloc( 1024 * sizeof( char) );
	char *tube_serveur = "tube_serveur";
	char *tube_client = "tube_client";

	testerEtCreerNamedPiped(tube_serveur);
	testerEtCreerNamedPiped(tube_client);

	char **tabMotRequte = NULL;

	while(1)
	{
		fdread = open(tube_serveur, O_RDONLY);
		//fcntl(fdread, F_SETFL, O_NONBLOCK);
		//read(fdread, input, NAME_SIZE);
		read(fdread, requete, 128 * sizeof( requete ) );
		close(fdread);

		writeToFile(pFile, requete );

		tabMotRequte = traiterRequete( requete );

		sauvegarderPid( client, tabMotRequte );

		repondreAuxClients( tabMotRequte, pFile, fdwrite, tube_client );

		quitterUnClient( tabMotRequte, client );

		if( quitterTousClients( tabMotRequte, pFile, client) ){
			unLinkTube( tube_serveur, tube_client);

			free( requete );
			free( tabMotRequte );
			break;
		}

	}
	return 0;
}

