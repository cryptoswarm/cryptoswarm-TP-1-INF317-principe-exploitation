#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <string.h>
#include  <signal.h>

/* Apres avoir lu la ligne entre par l'utilisateur. 
 * On passe cette ligne a la fonction ci-bas
 * On itere sur la longueur de la ligne et chaque fois qu'on trouve un espace, on enregistre le string dans un tableau.
 *
 * @param input, un string entre par l'utilisateur
 * @return un tableau de string.
 */
char **parseInput(char *input) {

    char **command = malloc(8 * sizeof(char *));
    if (command == NULL) {
    	perror("malloc failed");
        exit(1);
    }

    char *separator = " ";
    char *parsed;
    int index = 0;

    parsed = strtok(input, separator);
    while (parsed != NULL) {
    	command[index] = parsed;
        index++;
        parsed = strtok(NULL, separator);
    }
    command[index] = NULL;
    return command;
}

/* Si l'utilisateur entre seulement 'cd' sans que ca soit suivie d'un chemin
 * on afficherait le current working directory.
 * Sinon si le chemin est valide, on change le chemin
 * Sinon on afficherait un message d'erreur annoncant que le chemin n'est pas valide.
 *
 *@param argv, un tableau de string contenant la commande 'cd' suivie d'un chemin. 
 */
int changeDir(char* argv[] )
{
	char cwd[1024];
	const char *path;
	if( argv[1] == NULL)
	{
		printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
	}else{

		if( argv[1][strlen(argv[1]) -1 ] == '\n' ) argv[1][strlen(argv[1]) -1 ] = '\0'; //On enleve le '\n' car il cause une erreur dans chdir()
		path = argv[1];
		if( chdir(path) != 0 )
		{
			printf("%s\n","Erreur, le chemin n'existe pas");
		}
	}
	return 0;
}
/*
 *Permet a l'invite de commande d'avoir le chemin d'acces.
 *
 * @return le chemin d'acces du repertoir courant.
 */
char *trouverCheminAccesLigneCommande()
{
	char cwd[1024];
	char *chemin = (char*)malloc(1024*sizeof(char) );
	char *rl_prompt = getcwd( cwd, sizeof(cwd) );
	strcat(rl_prompt, " >>");
	strcpy(chemin, rl_prompt);

	return chemin;
}
/* Cette fonction utilise ce qu'on appelle escapes sequences pour effacer l'ecran.
 * \033 escape
 * [H home
 * [J new line
 * man ascii permet d'avoir plus d'informations.
 */
void clearScreaan()
{
	printf("\033[H\033[J");
}

void myexecl(char *argv[])
{
	int status;
	int pid = fork();
	if( pid < 0 )
	{
		perror("Echec du fork()");
		exit(1);
	}else if(pid == 0 )
	{
		if( execvp( argv[0],argv ) < 0 )
		{
			perror(argv[0]);
			perror("echec de execvp()");
			exit(1);
		}
	}else
	{
		waitpid(pid, &status, 0);//WUNTRACED);
	}
}

void listerContenuEnv(char *envp[])
{
	char **env;
	for(env = envp; *env !=0; env++)
	{
		char *this = *env;
		printf("%s\n",this);
	}
}

/* La fonction a pour but d'afficher le contenu du repertoir courant.
 *
 * @param un tableau de string, contenant dir <nom repertoir>
 */
int listerContenuDuRepertoir(char *argv[])
{
	 myexecl(argv);
	 return 0;
}

/*
 * Imprime le chemin du repertoir courant.
 */
void imprimeLeChemin(char *comment[])
{
     char cwd[1024];
     printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
}

/* Imprimer un commentaire suivie d'une nouvelle ligne
 *
 * @ comment un tableau de string contenant echo suivit d'un commentaire.
 */
void echoComment(char *comment[])
{
	myexecl(comment);
	printf("\n");

}
/* Afficher le man à l'aide du filtre « more ».
 */
void imprimerManuelUtilisateur()
{
	char *manCommand[] = {"man","more", NULL};
	myexecl(manCommand);
}
/*
 *
 */
 

/* Cette fonction permet l'execution des commandes internes ou des commandes venant d'un fichier.
 * On execute la fonction appropiee selon la commande entre par l'utilisateur
 * Elle permet l'execution de 9 commande
 *
 * @param parsed, une tableau contenant les commandes.
 * @param envp, un tableau des variables d'environnement. 
 */

int ownCmdHandler(char** parsed, char* envp[])
{
	int nbDeCommandes = 9;
	int i =0;
	int index = 0;
	char name[8];
	char* listeDeCommande[nbDeCommandes];

	listeDeCommande[0] = "cd"; 		//case 1
	listeDeCommande[1] = "clr"; 	//case 2
	listeDeCommande[2] = "dir"; 	//case 3
	listeDeCommande[3] = "environ"; //case 4
	listeDeCommande[4] = "echo";	//case 5
	listeDeCommande[5] = "help";	//case 6
	listeDeCommande[6] = "pause";	//case 7
	listeDeCommande[7] = "pwd";		//case 8
	listeDeCommande[8] = "quit";	//case 9

	if( parsed[0][strlen(parsed[0]) -1 ] == '\n' ) parsed[0][strlen(parsed[0]) -1 ] = '\0';

	for (i = 0; i < nbDeCommandes; i++)
	{
		if (strcmp(parsed[0], listeDeCommande[i]) == 0)
		{
	         index = i + 1;
	         break;
	    }
	}
	switch (index) {
		case 1:
			changeDir(parsed);
			printf("\n");
			return 1;
		case 2:
			clearScreaan();
			printf("\n");
			return 1;
		case 3:
			listerContenuDuRepertoir(parsed);
			printf("\n");
			return 1;
		case 4:
			listerContenuEnv(envp);
			printf("\n");
			return 1;
		case 5:
			echoComment(parsed);
			return 1;
		case 6:
			imprimerManuelUtilisateur();
			printf("\n");
			return 1;
		case 7:
			//pause();
			//signal(SIGINT, SIG_IGN);
			while(1)
			{
				fgets(name,8,stdin);
				if(strcmp(name, "\n") == 0 )
				{
					break;
				}
			}
			return 1;
		case 8:
			imprimeLeChemin( parsed );
			printf("\n");
			return 1;
		case 9:
			exit(0);
		default:
			printf("%s\n","La commande entree n'est pas supportee dans ce shell");
			printf("%s\n","Pour plus d'information, veuillez entrer la commande help");
			printf("\n");
			return 1;
	}

}
