#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <string.h>

char **parseInput(char *input) {

    char **command = malloc(8 * sizeof(char *));
    if (command == NULL) {
    	perror("malloc failed");
        exit(1);
    }

    char *separator = " ";
    char *parsed;
    int index = 0;

    parsed = strtok(input, separator);
    while (parsed != NULL) {
    	command[index] = parsed;
        index++;
        parsed = strtok(NULL, separator);
    }
    command[index] = NULL;
    return command;
}


int changeDir(char* argv[] )
{
	char cwd[1024];
	const char *path;
	if( argv[1] == NULL)
	{
		printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
	}else{

		if( argv[1][strlen(argv[1]) -1 ] == '\n' ) argv[1][strlen(argv[1]) -1 ] = '\0'; //On enleve le '\n' car il cause une erreur dans chdir()
		path = argv[1];
		if( chdir(path) != 0 )
		{
			printf("%s\n","Erreur, le chemin n'existe pas");
		}
	}
	return 0;
}

/* Cette fonction utilise ce qu'on appelle escapes sequences pour effacer l'ecran.
 * \033 escape
 * [H home
 * [J new line
 * man ascii permet d'avoir plus d'informations.
 */
void clearScreaan()
{
	printf("\033[H\033[J");
}

void myexecl(char *argv[])
{
	int status;
	int ret;
	int pid = fork();
	if( pid < 0 )
	{
		perror("Echec du fork()");
		exit(1);
	}else if(pid == 0 )
	{
		if( execvp( argv[0],argv ) < 0 )
		{
			perror(argv[0]);
			exit(1);
		}
	}else
	{
		waitpid(pid, &status, WUNTRACED);
	}
}

void listerContenuEnv(char *envp[])
{
	char **env;
	for(env = envp; *env !=0; env++)
	{
		char *this = *env;
		printf("%s\n",this);
	}
}



/**
int listContent()
{
	int status;
	int ret;
	int pid = fork();
	if( pid == -1 )
	{
		 perror("Echec du fork()");
	}else if(pid == 0 )
	{
		execl("/bin/ls","ls","-l",NULL);
		perror("error in execl()");
	}
	ret = waitpid(pid, &status, 0 );
	if(ret == -1)
	{
		perror("Erreur dans le waitpid() du premier processus enfant");
	}
	return 0;
}
*/
int listerContenuDuRepertoir(char *argv[])
{
     int status;
     int ret;
     int pid = fork();
     if( pid == -1 )
     {
          perror("Echec du fork()");
     }else if(pid == 0 )
     {
         if( execvp( argv[0],argv ) < 0 )
         {
             perror(argv[0]);
             exit(1);
         }
     }
     ret = waitpid(pid, &status, 0 );
     if(ret == -1)
     {
         perror("Erreur dans le waitpid() du premier processus enfant");
     }
     return 0;
}

/*
 * Imprime le chemin du repertoir courant.
 */
void imprimeLeChemin(char *comment[])
{
     char cwd[1024];
     printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
}

void echoComment(char *comment[])
{
	//echo comment;
	int index =1;
	while(comment[index] != NULL )
	{
		printf("%s ",comment[index]);
		++index;
	}
	printf("\n");
	printf("\n");
}

void imprimerManuelUtilisateur(char *readme)
{
	FILE *fp;
	char line[200];
	fp = fopen(readme, "r");
	while (fgets(line, 200, fp) != NULL)
	{
		printf("%s",line);
	}
	fclose(fp);
}

int ownCmdHandler(char** parsed, char* envp[])
{
	int nbDeCommandes = 9;
	int i =0;
	int index = 0;
	char* listeDeCommande[nbDeCommandes];

	listeDeCommande[0] = "cd"; 		//case 1
	listeDeCommande[1] = "clr"; 	//case 2
	listeDeCommande[2] = "dir"; 	//case 3
	listeDeCommande[3] = "environ"; //case 4
	listeDeCommande[4] = "echo";	//case 5
	listeDeCommande[5] = "help";	//case 6
	listeDeCommande[6] = "pause";	//case 7
	listeDeCommande[7] = "pwd";		//case 8
	listeDeCommande[8] = "quit";	//case 9

	if( parsed[0][strlen(parsed[0]) -1 ] == '\n' ) parsed[0][strlen(parsed[0]) -1 ] = '\0';

	for (i = 0; i < nbDeCommandes; i++)
	{
		if (strcmp(parsed[0], listeDeCommande[i]) == 0)
		{
	         index = i + 1;
	         break;
	    }
	}
	switch (index) {
		case 1:
			changeDir(parsed);
			printf("\n");
			return 1;
		case 2:
			clearScreaan();
			printf("\n");
			return 1;
		case 3:
			listerContenuDuRepertoir(parsed);
			printf("\n");
			return 1;
		case 4:
			listerContenuEnv(envp);
			printf("\n");
			return 1;
		case 5:
			echoComment(parsed);
			printf("\n");
			return 1;
		case 6:
			imprimerManuelUtilisateur("readme.md");
			printf("\n");
			return 1;
		case 7:
			pause();
			printf("\n");
			return 1;
		case 8:
			imprimeLeChemin( parsed );
			printf("\n");
			return 1;
		case 9:
			exit(0);
		default:
			printf("%s\n","La commande entree n'est pas supportee dans ce shell");
			printf("%s\n","Pour plus d'information, veuillez entrer la commande help");
			printf("\n");
			return 1;
	}

}
