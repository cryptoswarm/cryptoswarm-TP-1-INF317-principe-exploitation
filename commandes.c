/*
* Mokhtar Safir code permanent SAFM14118605
* David Carrier code permanent CARD26109601
*/

#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <string.h>
#include  <signal.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "interpretation.h"

/*
 *changer le output du stdout au fichier en utilisant la fonction dup2.
 *On fait un fork et on execute la command dup dans la partie fils.
 *le pere doit attendre.
 *
 *@param cmd, un tableau de commandes
 *@param fd, file descriptor
 */
void execCommandRedirect(int fd, char **cmd)
{
	int status;
	switch(fork() ){
	case 0:
		dup2(fd, 1); //remplacer standard output par le  output file
		execvp(cmd[0], cmd);
		perror(cmd[0]);
		exit(1);
	default:
		while(wait(&status) != -1);
		break;
	case -1:
		perror("erreur lors du fork");
	}
	return;
}


/* Si l'utilisateur entre seulement 'cd' sans que ca soit suivie d'un chemin
 * on afficherait le current working directory.
 * Sinon si le chemin est valide, on change le chemin
 * Sinon on afficherait un message d'erreur annoncant que le chemin n'est pas valide.
 *
 *@param argv, un tableau de string contenant la commande 'cd' suivie d'un chemin. 
 */
int changeDir(char* argv[] )
{

	char cwd[1024];
	const char *path;

	if( argv[1] == NULL) //si un argument est passé en ligne de commande
	{
		printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
	}else{

		if( argv[1][strlen(argv[1]) -1 ] == '\n' ) argv[1][strlen(argv[1]) -1 ] = '\0'; //On enleve le '\n' car il cause une erreur dans chdir()
		path = argv[1];
		if( chdir(path) != 0 )
		{
			printf("%s\n","Erreur, le chemin n'existe pas");
		}
	}
	return 0;
}
/*
 *Permet a l'invite de commande d'avoir le chemin d'acces.
 *
 * @return le chemin d'acces du repertoir courant.
 */
char *trouverCheminAccesLigneCommande()
{
	char cwd[1024];
	char *chemin = (char*)malloc(1024*sizeof(char) );
	char *rl_prompt = getcwd( cwd, sizeof(cwd) );
	strcat(rl_prompt, " >>");
	strcpy(chemin, rl_prompt);

	return chemin;
}
/* Cette fonction utilise ce qu'on appelle escapes sequences pour effacer l'ecran.
 * \033 escape
 * [H home
 * [J new line
 * man ascii permet d'avoir plus d'informations.
 */
void clearScreaan()
{
	printf("\033[H\033[J");
}

void myexecl(char *argv[])
{
	int status;
	int pid = fork();
	if( pid < 0 )
	{
		perror("Echec du fork()");
		exit(1);
	}else if(pid == 0 )
	{
		if( execvp( argv[0],argv ) < 0 )
		{
			perror(argv[0]);
			perror("echec de execvp()");
			exit(1);
		}
	}else
	{
		waitpid(pid, &status, 0);//WUNTRACED);
	}
}

/*
 * Lister le contenu des variables d'environnement
 * Si le char de redirection est present, on redirege le output vers la sortie adequate.
 *
 *@parm aragv: tableau de commandes.
 */
void listerContenuEnv(char *argv[])
{
	int newfd;
	char *cmd[] = { "/bin/env", 0 };
	if(argv[1] != NULL ) //si un argument est passé en ligne de commande
	{
		if( strcmp( argv[1],">") == 0 )
		{
			if ((newfd = open( argv[2], O_CREAT|O_TRUNC|O_WRONLY, 0644)) < 0)
			{
				perror(argv[1]);
				exit(1);
			}
		}else if( strcmp( argv[1],">>") == 0 )
		{
			if( ( newfd = open( argv[2], O_WRONLY|O_CREAT|O_APPEND, 0644 ) ) < 0 )
			{
				perror(argv[1]);
				exit(1);
			}
		}
		fflush(stdout);
		execCommandRedirect(newfd, cmd);
		close(newfd);
	}else
	{
		myexecl(cmd);
	}
}

/* La fonction a pour but d'afficher le contenu du repertoir courant.
 * Si le char de redirection est present, on redirege le output vers la sortie adequate.
 * @param un tableau de string, contenant dir <nom repertoir>
 */
int listerContenuDuRepertoir(char *argv[])
{
	int newfd;
	char *cmd[] = { "/bin/dir", 0 };
	if(argv[1] != NULL ) //si un argument est passé en ligne de commande
	{
		if( strcmp( argv[1],">") == 0 )
		{
			if ((newfd = open( argv[2], O_WRONLY|O_CREAT|O_TRUNC, 0644)) < 0)
			{
				perror(argv[1]);
				exit(1);
			}
		}else if( strcmp( argv[1],">>") == 0 )
		{
			if((newfd = open( argv[2], O_WRONLY|O_CREAT|O_APPEND, 0644)) < 0 )
			{
				perror(argv[1]);
				exit(1);
			}
		}
		fflush(stdout);
		execCommandRedirect(newfd, cmd);
		close(newfd);//exit(1);
	}else{

	 myexecl(argv);

	}
	return 0;
}

/*
 * Imprime le chemin du repertoir courant.
 */
void imprimeLeChemin(char *comment[])
{
     char cwd[1024];
     printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
}

/* Imprimer un commentaire suivie d'une nouvelle ligne
 * Si le char de redirection est present, on redirege le output vers la sortie adequate.
 * @ comment un tableau de string contenant echo suivit d'un commentaire.
 */
void echoComment(char *comment[])
{
	int newfd;
	int i;
	bool indice = 0;
	for(i = 1; comment[i] != NULL; i++)//trouver la position du sign de redirection
	{
		if( strcmp(comment[i], ">") == 0 || strcmp(comment[i], ">>") == 0 ){
			indice = 1;
			break;
		}
	}

	if( indice && i > 1)
	{
		if( strcmp( comment[i],">") == 0 )
		{
			if((newfd = open( comment[i+1], O_CREAT|O_TRUNC|O_WRONLY, 0644)) < 0)//on remplace le contenu de fichier
			{
				perror(comment[i+1]);
				exit(1);
			}
		}else if( strcmp( comment[i],">>") == 0 ) //ON ajoute a la fin de fichier s'il existe sinon on le cree et on ajoute
		{
			if((newfd = open( comment[i+1], O_WRONLY|O_CREAT|O_APPEND, 0644)) < 0 )
			{
				perror(comment[i+1]);
				exit(1);
			}
		}

		fflush(stdout);
		comment[i]= NULL; //remplacer le ">" ou ">>" par NULL
		comment[i+1]= NULL;//remplacer le nom de fichier par NULL
		execCommandRedirect(newfd, comment);
		close(newfd);
	}else
	{
		myexecl(comment);
		printf("\n");
	}
}
/* Afficher le man à l'aide du filtre « more ».
 * Si le char de redirection est present, on redirege le output vers la sortie adequate.
 */
void imprimerManuelUtilisateur(char *parsed[])
{
	char *manCommand[] = {"man","more", NULL};
	int newfd;
	if(parsed[1] != NULL ) //si un argument est passé en ligne de commande
	{
		if( strcmp( parsed[1],">") == 0 )
		{
			if((newfd = open( parsed[2], O_CREAT|O_TRUNC|O_WRONLY, 0644)) < 0)
			{
				perror(parsed[2]);
				exit(1);
			}
		}else if( strcmp( parsed[1],">>") == 0 )
		{
			if((newfd = open( parsed[2], O_WRONLY|O_CREAT|O_APPEND, 0644)) < 0 )
			{
				perror(parsed[2]);
				exit(1);
			}
		}
		fflush(stdout);
		execCommandRedirect(newfd, manCommand);
		close(newfd);
	}else
	{
		myexecl(manCommand);
	}
}

/* Cette fonction permet l'execution des commandes internes ou des commandes venant d'un fichier.
 * On execute la fonction appropiee selon la commande entre par l'utilisateur
 * Elle permet l'execution de 9 commande
 *
 * @param parsed, une tableau contenant les commandes.
 * @param envp, un tableau des variables d'environnement. 
 */

//int ownCmdHandler(CLIOptions *options, char* envp[])
int gererLesCommandes(char** parsed, char* envp[])
{
	int nbDeCommandes = 8;
	int i =0;
	int index = 0;
	char name[8];
	char* listeDeCommande[nbDeCommandes];

	listeDeCommande[0] = "cd"; 		//case 1
	listeDeCommande[1] = "clr"; 	//case 2
	listeDeCommande[2] = "dir"; 	//case 3
	listeDeCommande[3] = "environ"; //case 4
	listeDeCommande[4] = "echo";	//case 5
	listeDeCommande[5] = "help";	//case 6
	listeDeCommande[6] = "pause";	//case 7
	listeDeCommande[7] = "quit";	//case 8

	if( parsed[0][strlen(parsed[0]) -1 ] == '\n' ) parsed[0][strlen(parsed[0]) -1 ] = '\0';


	bool background = 0; //en arriere-plan
	int fork_value = 0;
	for(int i = 0; parsed[i] != NULL; i++){
		if(strcmp(parsed[i], "&") == 0 && !background){
			background = 1;
			fork_value = fork();
		} //esperluette présente
	}

	if(!background || fork_value == 0){ //si n<est pas une tache d'arriere-plan ou est l'enfant

		for (i = 0; i < nbDeCommandes; i++)
		{
			if (strcmp(parsed[0], listeDeCommande[i]) == 0)
			{
			 index = i + 1;
			 break;
		    }
		}
		switch (index) {
			case 1:
				changeDir(parsed);
				printf("\n");
				return 1;
			case 2:
				clearScreaan();
				printf("\n");
				return 1;
			case 3:
				listerContenuDuRepertoir(parsed);
				printf("\n");
				return 1;
			case 4:
				listerContenuEnv(parsed);
				printf("\n");
				return 1;
			case 5:
				echoComment(parsed);
				return 1;
			case 6:
				imprimerManuelUtilisateur(parsed);
				printf("\n");
				return 1;
			case 7:
				//pause();
				//signal(SIGINT, SIG_IGN);
				while(1)
				{
					fgets(name,8,stdin);
					if(strcmp(name, "\n") == 0 )
					{
						break;
					}
				}
				return 1;
			case 8:
				exit(0);
			default:
				myexecl(parsed);
				return 1;
		}
	}
	if(fork_value == 0){ //terminer l'enfant apres une commande
		return 0;
	}
	return 0;
}
