#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <string.h>

char **parseInput(char *input) {

    char **command = malloc(8 * sizeof(char *));
    if (command == NULL) {
    	perror("malloc failed");
        exit(1);
    }

    char *separator = " ";
    char *parsed;
    int index = 0;

    parsed = strtok(input, separator);
    while (parsed != NULL) {
    	command[index] = parsed;
        index++;

        parsed = strtok(NULL, separator);
    }

    command[index] = NULL;
    return command;
}


int changeDir(char* argv[] )
{
	char cwd[1024];
	const char *path;
	if( argv[1] == NULL)
	{
		printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
	}else{
		path = argv[1];
		if( chdir(path) != 0 )
		{
			printf("%s\n","Erreur, le chemin n'existe pas");
		}
	}
	return 0;
}

/* Cette fonction utilise ce qu'on appelle escapes sequences pour effacer l'ecran.
 * \033 escape
 * [H home
 * [J new line
 * man ascii permet d'avoir plus d'informations.
 */
void clearScreaan()
{
	printf("\033[H\033[J");
}
/**
int listContentOfDirectory()
{
	return dir();
}
*/
void myexecl(char *argv[])
{
	int status;
	int ret;
	int pid = fork();
	if( pid < 0 )
	{
		perror("Echec du fork()");
		exit(1);
	}else if(pid == 0 )
	{
		if( execvp( argv[0],argv ) < 0 )
		{
			perror(argv[0]);
			exit(1);
		}
	}else
	{
		waitpid(pid, &status, WUNTRACED);
	}
}

void listerContenuEnv(char *envp[])
{
	char **env;
	for(env = envp; *env !=0; env++)
	{
		char *this = *env;
		printf("%s\n",this);
	}
}



/**
int listContent()
{
	int status;
	int ret;
	int pid = fork();
	if( pid == -1 )
	{
		 perror("Echec du fork()");
	}else if(pid == 0 )
	{
		execl("/bin/ls","ls","-l",NULL);
		perror("error in execl()");
	}
	ret = waitpid(pid, &status, 0 );
	if(ret == -1)
	{
		perror("Erreur dans le waitpid() du premier processus enfant");
	}
	return 0;
}
*/
int listerContenuDuRepertoir(char *argv[])
{
     int status;
     int ret;
     int pid = fork();
     //char
     if( pid == -1 )
     {
          perror("Echec du fork()");
     }else if(pid == 0 )
     {
         //execl("/bin/ls","ls","-l",NULL);
         //execl("/bin/ls","ls","-l",NULL);
         //perror("error in execl()");
         if( execvp( argv[0],argv ) < 0 )
         {
             perror(argv[0]);
             exit(1);
         }
     }
     ret = waitpid(pid, &status, 0 );
     if(ret == -1)
     {
         perror("Erreur dans le waitpid() du premier processus enfant");
     }
     return 0;
}

/*
 * Imprime le chemin du repertoir courant.
 */
void imprimeLeChemin(char *comment[])
{
     char cwd[1024];
     printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
}

void echoComment(char *comment[])
{
	//echo comment;
	int index =1;
	while(comment[index] != NULL )
	{
		printf("%s ",comment[index]);
		++index;
	}
	printf("\n");
	printf("\n");
}

int ownCmdHandler(char** parsed, char* envp[])
{
	if( strcmp( parsed[0], "cd" ) == 0)
	{
		changeDir(parsed);
	}
	if( strcmp( parsed[0], "pwd" ) == 0)
	{
		imprimeLeChemin( parsed );
	}
	if( strcmp( parsed[0], "clr" ) == 0)
	{
		clearScreaan();
	}
	if(strcmp( parsed[0], "dir" ) == 0)
	{
		//listContentOfDirectory();
		//continue;
		listerContenuDuRepertoir( parsed);
	}
	if(strcmp( parsed[0], "environ" ) == 0)
	{
		listerContenuEnv(envp);
	}
	if(strcmp( parsed[0], "echo" ) == 0)
	{
		echoComment(parsed);
	}
	if( strcmp( parsed[0], "quit" ) == 0)
	{
		exit(0);
	}

}
