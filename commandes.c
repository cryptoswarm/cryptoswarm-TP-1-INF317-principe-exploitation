#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <string.h>
#include  <signal.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "interpretation.h"

void execCommandRedirect(int fd, char **cmd)
{
	int status;
	switch(fork() ){
	case 0:
		dup2(fd, 1);
		execvp(cmd[0], cmd);
		perror(cmd[0]);
		exit(1);
	default:
		while(wait(&status) != -1);
		break;
	case -1:
		perror("erreur lors du fork");
	}
	return;
}


/* Si l'utilisateur entre seulement 'cd' sans que ca soit suivie d'un chemin
 * on afficherait le current working directory.
 * Sinon si le chemin est valide, on change le chemin
 * Sinon on afficherait un message d'erreur annoncant que le chemin n'est pas valide.
 *
 *@param argv, un tableau de string contenant la commande 'cd' suivie d'un chemin. 
 */
int changeDir(char* argv[] )
{

	char cwd[1024];
	const char *path;

	if( argv[1] == NULL)
	{
		printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
	}else{

		if( argv[1][strlen(argv[1]) -1 ] == '\n' ) argv[1][strlen(argv[1]) -1 ] = '\0'; //On enleve le '\n' car il cause une erreur dans chdir()
		path = argv[1];
		if( chdir(path) != 0 )
		{
			printf("%s\n","Erreur, le chemin n'existe pas");
		}
	}
	return 0;
}
/*
 *Permet a l'invite de commande d'avoir le chemin d'acces.
 *
 * @return le chemin d'acces du repertoir courant.
 */
char *trouverCheminAccesLigneCommande()
{
	char cwd[1024];
	char *chemin = (char*)malloc(1024*sizeof(char) );
	char *rl_prompt = getcwd( cwd, sizeof(cwd) );
	strcat(rl_prompt, " >>");
	strcpy(chemin, rl_prompt);

	return chemin;
}
/* Cette fonction utilise ce qu'on appelle escapes sequences pour effacer l'ecran.
 * \033 escape
 * [H home
 * [J new line
 * man ascii permet d'avoir plus d'informations.
 */
void clearScreaan()
{
	printf("\033[H\033[J");
}

void myexecl(char *argv[])
{
	int status;
	int pid = fork();
	if( pid < 0 )
	{
		perror("Echec du fork()");
		exit(1);
	}else if(pid == 0 )
	{
		if( execvp( argv[0],argv ) < 0 )
		{
			perror(argv[0]);
			perror("echec de execvp()");
			exit(1);
		}
	}else
	{
		waitpid(pid, &status, 0);//WUNTRACED);
	}
}

void listerContenuEnv(char *argv[])
{
	int newfd;
	char *cmd[] = { "/bin/env", 0 };
	if(argv[1] != NULL )
	{
		if( strcmp( argv[1],">") == 0  || strcmp( argv[1],">>") == 0 )
		{
			if ((newfd = open( argv[2], O_CREAT|O_TRUNC|O_WRONLY, 0644)) < 0)
			{
				perror(argv[1]);
				exit(1);
			}
		}
		fflush(stdout);
		execCommandRedirect(newfd, cmd);
		close(newfd);
	}else
	{
		myexecl(cmd);
	}
}

/* La fonction a pour but d'afficher le contenu du repertoir courant.
 *
 * @param un tableau de string, contenant dir <nom repertoir>
 */
int listerContenuDuRepertoir(char *argv[])
{
	int newfd;
	char *cmd[] = { "/bin/dir", 0 };
	if(argv[1] != NULL )
	{
		if( strcmp( argv[1],">") == 0  || strcmp( argv[1],">>") == 0 )
		{
			if ((newfd = open( argv[2], O_CREAT|O_TRUNC|O_WRONLY, 0644)) < 0)
			{
				perror(argv[1]);
				exit(1);
			}
		}
		fflush(stdout);
		execCommandRedirect(newfd, cmd);
		close(newfd);//exit(1);
	}else{

	 myexecl(argv);

	}
	return 0;
}

/*
 * Imprime le chemin du repertoir courant.
 */
void imprimeLeChemin(char *comment[])
{
     char cwd[1024];
     printf("%s\n",getcwd( cwd, sizeof(cwd) ) );
}

/* Imprimer un commentaire suivie d'une nouvelle ligne
 *
 * @ comment un tableau de string contenant echo suivit d'un commentaire.
 */
void echoComment(char *comment[])
{
	 int newfd;
	 char *cmd[] = { "/bin/echo", 0 };
	if(comment[2] != NULL )
	{
		if( strcmp( comment[2],">") == 0  || strcmp( comment[2],">>") == 0 )
		{
			if((newfd = open( comment[3], O_CREAT|O_TRUNC|O_WRONLY, 0644)) < 0)
			{
				perror(comment[3]);
				exit(1);
			}
		}
		fflush(stdout);
		execCommandRedirect(newfd, comment);
		close(newfd);
	}else
	{
		myexecl(comment);
		printf("\n");
	}

}
/* Afficher le man à l'aide du filtre « more ».
 */
void imprimerManuelUtilisateur()
{
	char *manCommand[] = {"man","more", NULL};
	myexecl(manCommand);
}
/*
 *
 */


/* Cette fonction permet l'execution des commandes internes ou des commandes venant d'un fichier.
 * On execute la fonction appropiee selon la commande entre par l'utilisateur
 * Elle permet l'execution de 9 commande
 *
 * @param parsed, une tableau contenant les commandes.
 * @param envp, un tableau des variables d'environnement. 
 */

//int ownCmdHandler(CLIOptions *options, char* envp[])
int ownCmdHandler(char** parsed, char* envp[])
{
	int nbDeCommandes = 8;
	int i =0;
	int index = 0;
	char name[8];
	char* listeDeCommande[nbDeCommandes];
	
	//FILE* original_stdin = stdin; //constantes contenues dans stdio
	//FILE* original_stdout = stdout;

	listeDeCommande[0] = "cd"; 		//case 1
	listeDeCommande[1] = "clr"; 	//case 2
	listeDeCommande[2] = "dir"; 	//case 3
	listeDeCommande[3] = "environ"; //case 4
	listeDeCommande[4] = "echo";	//case 5
	listeDeCommande[5] = "help";	//case 6
	listeDeCommande[6] = "pause";	//case 7
	listeDeCommande[7] = "quit";	//case 8
	
	
	//char** parsed = options->command; 
	if( parsed[0][strlen(parsed[0]) -1 ] == '\n' ) parsed[0][strlen(parsed[0]) -1 ] = '\0';
	
	//redirections vers les streams nécessaires (habituellement stdin et stdout)
	//stdin = options->inputStream;
	//stdout = options->outputStream;

	for (i = 0; i < nbDeCommandes; i++)
	{
		if (strcmp(parsed[0], listeDeCommande[i]) == 0)
		{
	         index = i + 1;
	         break;
	    }
	}
	switch (index) {
		case 1:
			changeDir(parsed);
			printf("\n");
			return 1;
		case 2:
			clearScreaan();
			printf("\n");
			return 1;
		case 3:
			listerContenuDuRepertoir(parsed);
			printf("\n");
			return 1;
		case 4:
			listerContenuEnv(parsed);
			printf("\n");
			return 1;
		case 5:
			echoComment(parsed);
			return 1;
		case 6:
			imprimerManuelUtilisateur();
			printf("\n");
			return 1;
		case 7:
			//pause();
			//signal(SIGINT, SIG_IGN);
			while(1)
			{
				fgets(name,8,stdin);
				if(strcmp(name, "\n") == 0 )
				{
					break;
				}
			}
			return 1;
		case 8:
			exit(0);
		default:
			printf("%s\n","La commande entree n'est pas supportee dans ce shell");
			printf("%s\n","Pour plus d'information, veuillez entrer la commande help");
			printf("\n");
			return 1;
	}
	
	//remettre les streams d'origine
	//stdin = original_stdin;
	//stdout = original_stdout;
}
